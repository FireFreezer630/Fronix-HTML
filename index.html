<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
  <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Fronix.ai</title>
  
  <!-- Libraries -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Work+Sans:wght@300;400;500;600;700&family=Yu+Gothic&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

  <!-- ADDED: highlight.js for Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          fontFamily: { inter: ['Inter', 'sans-serif'], 'work-sans': ['Work Sans', 'sans-serif'], 'yu-gothic': ['Yu Gothic', 'sans-serif'], 'sans-serif': ['ui-sans-serif', 'system-ui', '-apple-system'] },
          borderRadius: { '3xl': '24px' },
          colors: {
            light: { background: '#FFFFFF', sidebar: '#F7F7F8', 'user-bubble': '#F0F0F0', 'chat-surface': '#FFFFFF', border: '#E5E5E6', 'border-hover': '#ECECEC', 'border-active': '#E0E0E0', text: { DEFAULT: '#18181B', subtle: '#6B7280' } },
            dark: { background: '#121212', sidebar: '#1C1C1C', 'user-bubble': '#2C2C2C', 'chat-surface': '#121212', border: '#3A3A3A', 'border-hover': '#2A2A2A', 'border-active': '#303030', text: { DEFAULT: '#EAEAEA', subtle: '#A1A1AA' } },
            accent: { DEFAULT: '#4F46E5', hover: '#4338CA' }
          }
        }
      }
    }
  </script>
  <style>
    body { -webkit-text-size-adjust: 100%; -webkit-tap-highlight-color: transparent; line-height: 1.5; }
    :not(.vt-enabled) * { transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
    @media (max-width: 767px) { #sidebar { position: fixed; z-index: 40; height: 100%; transform: translateX(-100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); } #sidebar.open { transform: translateX(0); } #sidebar-overlay { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.5); z-index: 30; opacity: 0; transition: opacity 0.3s ease-in-out; pointer-events: none; } #sidebar-overlay.open { opacity: 1; pointer-events: auto; } }
    .sidebar-item-actions { opacity: 0; transition: opacity 0.15s ease-in-out; }
    .group:hover .sidebar-item-actions { opacity: 1; }
    .modal-container { position: fixed; inset: 0; z-index: 50; display: none; align-items: center; justify-content: center; background-color: rgba(0,0,0,0.4); padding: 1rem; padding-bottom: 5rem; } /* Added padding for mobile */
    .modal-content { transform: scale(0.95); opacity: 0; max-height: 90vh; overflow-y: auto; } /* Added max-height and overflow for scrolling */
    #model-dropdown, #chat-actions-dropdown { display: none; position: absolute; z-index: 50; }
    .loader-dot {
        animation: loaderBounce 1.4s infinite ease-in-out both;
    }

    .image-generation-spinner {
        width: 1.5rem;
        height: 1.5rem;
        border-radius: 9999px;
        border-width: 2px;
        border-style: solid;
        border-color: rgba(255,255,255,0.15);
        border-top-color: rgba(255,255,255,0.6);
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }

    .image-generation-spinner.active {
        animation: spin 1s linear infinite;
    }

    .loader-dot:nth-child(2) { animation-delay: 0.15s; }
    .loader-dot:nth-child(3) { animation-delay: 0.3s; }

    @keyframes reveal {
      from {
        clip-path: circle(0 at var(--cx) var(--cy));
      }
      to {
        clip-path: circle(150% at var(--cx) var(--cy));
      }
    }

    ::view-transition-old(root) {
      animation: none;
    }

    ::view-transition-new(root) {
      animation: reveal 0.6s ease-in-out both;
    }
    .blinking-cursor { display: inline-block; width: 8px; height: 8px; background-color: currentColor; border-radius: 50%; animation: blink 1s infinite; }
    
    /* --- ADDED: CUSTOM PROSE STYLING --- */
    .prose {
      line-height: 1.7;
      color: var(--tw-prose-body); /* Fallback for browsers not supporting @apply */
    }
    .dark .prose {
        color: var(--tw-prose-invert-body);
    }
    
    .prose h1, .prose h2, .prose h3, .prose h4, .prose h5, .prose h6 { 
      margin-top: 1.5em; 
      margin-bottom: 0.5em; 
      font-weight: 600;
      color: var(--tw-prose-headings);
    }
    .dark .prose h1, .dark .prose h2, .dark .prose h3, .dark .prose h4, .dark .prose h5, .dark .prose h6 { 
        color: var(--tw-prose-invert-headings);
    }
    .prose h1 { font-size: 1.875rem; } /* text-3xl */
    .prose h2 { font-size: 1.5rem; }    /* text-2xl */
    .prose h3 { font-size: 1.25rem; }  /* text-xl */
    .prose h4 { font-size: 1.125rem; } /* text-lg */

    .prose a { color: #4F46E5; text-decoration: none; }
    .prose a:hover { text-decoration: underline; }
    .dark .prose a { color: #6D6AEC; }

    .prose blockquote {
        border-left: 4px solid #E5E5E6;
        padding-left: 1rem;
        font-style: italic;
        color: #6B7280;
    }
    .dark .prose blockquote {
        border-left-color: #3A3A3A;
        color: #A1A1AA;
    }

    .prose code:not(pre > code) {
        background-color: #F0F0F0;
        color: #18181B;
        border-radius: 0.375rem; /* rounded-md */
        padding: 0.25rem 0.5rem;
        font-size: 0.875em;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    .dark .prose code:not(pre > code) {
        background-color: #2C2C2C;
        color: #EAEAEA;
    }
    
    .prose pre {
        background-color: #282c34; /* atom-one-dark background */
        border-radius: 0.5rem; /* rounded-lg */
        box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        overflow: hidden;
    }
    .prose pre code {
      background-color: transparent;
      padding: 1rem;
      display: block;
      overflow-x: auto;
      font-size: 0.875em;
      color: #abb2bf; /* Default text color for atom-one-dark */
    }

    .prose ul { list-style-type: disc; padding-left: 1.75rem; }
    .prose ol { list-style-type: decimal; padding-left: 1.75rem; }
    .prose li { margin-top: 0.25rem; margin-bottom: 0.25rem; }

    .prose table { width: 100%; border-collapse: collapse; }
    .prose th, .prose td { border: 1px solid #E5E5E6; padding: 0.5rem 1rem; }
    .dark .prose th, .dark .prose td { border-color: #3A3A3A; }
    .prose th { background-color: #F7F7F8; font-weight: 600; }
    .dark .prose th { background-color: #1C1C1C; }
    .prose tr:nth-child(even) { background-color: #F7F7F8; }
    .dark .prose tr:nth-child(even) { background-color: #1C1C1C; }

    .prose hr { border-color: #E5E5E6; margin-top: 2rem; margin-bottom: 2rem; }
    .dark .prose hr { border-color: #3A3A3A; }

    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
    @keyframes pendulum { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }
    
    /* Loading spinner animation */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .loading-spinner {
      border: 2px solid transparent;
      border-top: 2px solid currentColor;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-right: 8px;
    }
    
    /* Custom scrollbar for model dropdown */
    #model-dropdown::-webkit-scrollbar {
      width: 6px;
    }
    
    #model-dropdown::-webkit-scrollbar-track {
      background: transparent;
    }
    
    #model-dropdown::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }
    
    .dark #model-dropdown::-webkit-scrollbar-thumb {
      background: #475569;
    }
    
    #model-dropdown::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }
    
    .dark #model-dropdown::-webkit-scrollbar-thumb:hover {
      background: #64748b;
    }
    
    /* Custom alert styles aligned with app design */
    .custom-alert {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 9999;
      min-width: 280px;
      max-width: 420px;
      padding: 12px 14px;
      border-radius: 12px;
      box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      transform: translateX(100%);
      opacity: 0;
      transition: transform 0.25s ease, opacity 0.25s ease;
      display: flex;
      align-items: flex-start;
      gap: 10px;
      border: 1px solid;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system;
    }
    
    .custom-alert.show {
      transform: translateX(0);
      opacity: 1;
    }
    
    .custom-alert.success {
      background-color: #ECFDF5;
      color: #065F46;
      border-color: #A7F3D0;
    }
    .dark .custom-alert.success {
      background-color: rgba(16,185,129,0.12);
      color: #D1FAE5;
      border-color: rgba(16,185,129,0.35);
    }
    
    .custom-alert.error {
      background-color: #FEF2F2;
      color: #991B1B;
      border-color: #FECACA;
    }
    .dark .custom-alert.error {
      background-color: rgba(239,68,68,0.12);
      color: #FCA5A5;
      border-color: rgba(239,68,68,0.35);
    }
    
    .custom-alert.warning {
      background-color: #FFFBEB;
      color: #92400E;
      border-color: #FDE68A;
    }
    .dark .custom-alert.warning {
      background-color: rgba(245,158,11,0.12);
      color: #FCD34D;
      border-color: rgba(245,158,11,0.35);
    }
    
    .custom-alert.info {
      background-color: #EFF6FF;
      color: #1E3A8A;
      border-color: #BFDBFE;
    }
    .dark .custom-alert.info {
      background-color: rgba(59,130,246,0.12);
      color: #93C5FD;
      border-color: rgba(59,130,246,0.35);
    }
    
    .alert-content {
      flex: 1;
      font-size: 0.9rem;
      line-height: 1.5;
    }
    
    .alert-close {
      background: none;
      border: none;
      color: currentColor;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      opacity: 0.8;
      padding: 2px;
      line-height: 1;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
    }
    
    .alert-close:hover {
      opacity: 1;
      background-color: rgba(0,0,0,0.06);
    }
    .dark .alert-close:hover {
      background-color: rgba(255,255,255,0.08);
    }
    
    /* Loading spinner for sync indicator */
    .loading-spinner {
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-left: 2px solid currentColor;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    .dark .loading-spinner {
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-left: 2px solid currentColor;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body class="h-full bg-light-background dark:bg-dark-background flex overflow-hidden text-light-text dark:text-dark-text font-inter font-normal">
  
  <div id="sidebar-overlay"></div>
  
  <aside id="sidebar" class="bg-light-sidebar dark:bg-dark-sidebar flex-shrink-0 flex flex-col w-[260px]">
    <div class="p-4 flex items-center gap-3">
      <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-accent"><path d="M12 2L2 7l10 5 10-5-10-5z"></path><path d="M2 17l10 5 10-5"></path><path d="M2 12l10 5 10-5"></path></svg>
      <span class="text-xl font-bold">Fronix</span>
    </div>
    <div class="p-2"><button id="new-chat" class="w-full flex items-center justify-center gap-2 px-4 py-2.5 bg-accent hover:bg-accent-hover text-white font-semibold rounded-lg shadow-sm transition-all duration-200 ease-in-out transform hover:scale-105"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M2.6687 11.333V8.66699C2.6687 7.74455 2.66841 7.01205 2.71655 6.42285C2.76533 5.82612 2.86699 5.31731 3.10425 4.85156L3.25854 4.57617C3.64272 3.94975 4.19392 3.43995 4.85229 3.10449L5.02905 3.02149C5.44666 2.84233 5.90133 2.75849 6.42358 2.71582C7.01272 2.66769 7.74445 2.66797 8.66675 2.66797H9.16675C9.53393 2.66797 9.83165 2.96586 9.83179 3.33301C9.83179 3.70028 9.53402 3.99805 9.16675 3.99805H8.66675C7.7226 3.99805 7.05438 3.99834 6.53198 4.04102C6.14611 4.07254 5.87277 4.12568 5.65601 4.20313L5.45581 4.28906C5.01645 4.51293 4.64872 4.85345 4.39233 5.27149L4.28979 5.45508C4.16388 5.7022 4.08381 6.01663 4.04175 6.53125C3.99906 7.05373 3.99878 7.7226 3.99878 8.66699V11.333C3.99878 12.2774 3.99906 12.9463 4.04175 13.4688C4.08381 13.9833 4.16389 14.2978 4.28979 14.5449L4.39233 14.7285C4.64871 15.1465 5.01648 15.4871 5.45581 15.7109L5.65601 15.7969C5.87276 15.8743 6.14614 15.9265 6.53198 15.958C7.05439 16.0007 7.72256 16.002 8.66675 16.002H11.3337C12.2779 16.002 12.9461 16.0007 13.4685 15.958C13.9829 15.916 14.2976 15.8367 14.5447 15.7109L14.7292 15.6074C15.147 15.3511 15.4879 14.9841 15.7117 14.5449L15.7976 14.3447C15.8751 14.128 15.9272 13.8546 15.9587 13.4688C16.0014 12.9463 16.0017 12.2774 16.0017 11.333V10.833C16.0018 10.466 16.2997 10.1681 16.6667 10.168C17.0339 10.168 17.3316 10.4659 17.3318 10.833V11.333C17.3318 12.2555 17.3331 12.9879 17.2849 13.5771C17.2422 14.0993 17.1584 14.5541 16.9792 14.9717L16.8962 15.1484C16.5609 15.8066 16.0507 16.3571 15.4246 16.7412L15.1492 16.8955C14.6833 17.1329 14.1739 17.2354 13.5769 17.2842C12.9878 17.3323 12.256 17.332 11.3337 17.332H8.66675C7.74446 17.332 7.01271 17.3323 6.42358 17.2842C5.90135 17.2415 5.44665 17.1577 5.02905 16.9785L4.85229 16.8955C4.19396 16.5601 3.64271 16.0502 3.25854 15.4238L3.10425 15.1484C2.86697 14.6827 2.76534 14.1739 2.71655 13.5771C2.66841 12.9879 2.6687 12.2555 2.6687 11.333ZM13.4646 3.11328C14.4201 2.334 15.8288 2.38969 16.7195 3.28027L16.8865 3.46485C17.6141 4.35685 17.6143 5.64423 16.8865 6.53613L16.7195 6.7207L11.6726 11.7686C11.1373 12.3039 10.4624 12.6746 9.72827 12.8408L9.41089 12.8994L7.59351 13.1582C7.38637 13.1877 7.17701 13.1187 7.02905 12.9707C6.88112 12.8227 6.81199 12.6134 6.84155 12.4063L7.10132 10.5898L7.15991 10.2715C7.3262 9.53749 7.69692 8.86241 8.23218 8.32715L13.2791 3.28027L13.4646 3.11328ZM15.7791 4.2207C15.3753 3.81702 14.7366 3.79124 14.3035 4.14453L14.2195 4.2207L9.17261 9.26856C8.81541 9.62578 8.56774 10.0756 8.45679 10.5654L8.41772 10.7773L8.28296 11.7158L9.22241 11.582L9.43433 11.543C9.92426 11.432 10.3749 11.1844 10.7322 10.8271L15.7791 5.78027L15.8552 5.69629C16.185 5.29194 16.1852 4.708 15.8552 4.30371L15.7791 4.2207Z"></path></svg>New Chat</button></div>
    <div class="mt-6 px-4 text-xs font-semibold text-light-text-subtle dark:text-dark-text-subtle tracking-wider">Chats</div>
    <ul id="chat-list" class="flex-1 overflow-y-auto px-2 mt-2 space-y-1"></ul>
    
    <!-- ++ START: NEW PROFILE SECTION ++ -->
    <div id="profile-section" class="relative hidden">
        <!-- This is the dropdown panel that appears when the profile button is clicked -->
        <div id="profile-dropdown" class="absolute bottom-full left-0 w-full p-4 mb-2 hidden">
            <div class="bg-light-background dark:bg-dark-background p-4 rounded-lg shadow-lg border border-light-border dark:border-dark-border">
                <div class="font-semibold text-light-text dark:text-dark-text" id="profile-username"></div>
                <div class="text-sm text-light-text-subtle dark:text-dark-text-subtle" id="profile-email"></div>
                <div class="mt-2 text-xs">
                    <span class="font-medium">Plan:</span>
                    <span class="bg-accent/10 text-accent font-semibold px-2 py-0.5 rounded-full" id="profile-plan"></span>
                </div>
            </div>
        </div>
        <!-- This is the main button visible at the bottom of the sidebar -->
        <button id="profile-btn" class="w-full flex items-center justify-between p-3 hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-colors">
            <div class="flex items-center gap-3">
                <div class="w-8 h-8 rounded-full bg-accent flex items-center justify-center text-white font-bold">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                </div>
                <span class="text-sm font-medium" id="profile-btn-username"></span>
            </div>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-light-text-subtle dark:text-dark-text-subtle"><path d="m18 15-6-6-6 6"></path></svg>
        </button>
    </div>
    <!-- ++ END: NEW PROFILE SECTION ++ -->

    <div class="p-4 border-t border-light-border dark:border-dark-border">
        <div class="flex items-center justify-between">
            <div class="flex items-center gap-3 text-sm">
                <button id="signin-btn" class="flex items-center gap-2 px-4 py-2 text-sm font-medium rounded-md hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line></svg>
                    Sign In
                </button>
                <!-- MODIFIED LOGOUT BUTTON -->
                <button id="logout-btn" class="flex items-center gap-2 px-4 py-2 text-sm font-medium rounded-md hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-colors hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>
                    <span>Sign Out</span>
                </button>
            </div>
            <div class="flex items-center">
                <button id="settings-btn" class="p-2 rounded-md hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                </button>
                <button id="theme-toggle" class="p-2 rounded-md hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-colors">
                    <svg id="theme-icon-light" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                    <svg id="theme-icon-dark" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                </button>
            </div>
        </div>
    </div>
  </aside>

  <div id="main-container" class="flex-1 flex flex-col min-w-0">
    <header class="bg-light-chat-surface dark:bg-dark-chat-surface px-4 py-3 flex items-center gap-4 relative">
      <button id="toggle-sidebar" class="p-2 text-light-text-subtle dark:text-dark-text-subtle hover:text-light-text dark:hover:text-dark-text rounded-full"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h7" /></svg></button>
      <div id="model-selector" class="flex items-center gap-2 cursor-pointer hover:bg-light-border-hover dark:hover:bg-dark-border-hover rounded-lg px-3 py-2 transition-colors">
        <h1 id="chat-title" class="text-lg font-semibold truncate">Fronix</h1>
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-light-text-subtle dark:text-dark-text-subtle flex-shrink-0 transition-transform" id="model-dropdown-arrow"><path d="m6 9 6 6 6-6"></path></svg>
      </div>
      
      <!-- Study Mode Indicator -->
      <div id="study-mode-indicator" class="hidden flex items-center gap-2 px-3 py-1 bg-blue-100 dark:bg-blue-900/30 rounded-full text-xs font-medium text-blue-800 dark:text-blue-200">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
          <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
        </svg>
        <span>Study Mode</span>
      </div>
      
      <div id="model-dropdown" class="absolute top-full left-4 mt-2 w-72 bg-light-sidebar dark:bg-dark-sidebar rounded-lg shadow-lg border border-light-border dark:border-dark-border z-10 max-h-96 overflow-y-auto"></div>
    </header>
    <main class="flex-1 overflow-hidden flex flex-col bg-light-chat-surface dark:bg-dark-chat-surface">
      <div id="chat-box-wrapper" class="flex-1 overflow-y-auto px-4 sm:px-8 md:px-12 lg:px-24">
        <div id="chat-box" class="max-w-4xl mx-auto pb-20 space-y-6">
          <div class="text-center text-light-text-subtle dark:text-dark-text-subtle py-8">
            <h2 class="text-3xl font-bold mb-2">Fronix</h2>
            <p>Start a new message to begin.</p>
          </div>
        </div>
      </div>
      <!-- START of the corrected input area -->
      <div class="relative">

        <!-- Scroll To Bottom Button -->
        <button id="scroll-to-bottom-btn" class="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-4 p-2 rounded-full bg-light-sidebar dark:bg-dark-sidebar shadow-md border border-light-border dark:border-dark-border text-light-text-subtle dark:text-dark-text-subtle hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-opacity duration-300 opacity-0 pointer-events-none">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"></path><path d="m19 12-7 7-7-7"></path></svg>
        </button>
        
        <!-- Corrected Edit Indicator: Single element with corrected layout -->
        <div id="edit-indicator" class="max-w-3xl mx-auto px-3 py-2 flex items-center justify-between bg-blue-100 dark:bg-blue-900/30 rounded-t-lg text-sm font-medium text-gray-800 dark:text-gray-100 hidden">
            <div class="flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="flex-shrink-0 text-blue-600 dark:text-blue-400">
                    <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                </svg>
                <span>Editing message</span>
            </div>
            <button id="cancel-edit-btn" class="p-1 rounded-full hover:bg-black/10 dark:hover:bg-white/10 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>
        </div>

        <!-- ADDED: Image Preview Container -->
        <div id="image-preview-container" class="max-w-3xl mx-auto p-4 hidden">
            <!-- Image preview will be dynamically inserted here by JavaScript -->
        </div>

        <!-- Input Bar -->
        <div class="max-w-3xl mx-auto p-4 relative">
          <div class="flex items-end space-x-2 p-2 rounded-2xl bg-light-sidebar dark:bg-dark-sidebar shadow-lg">
            <input type="file" id="image-upload" class="hidden" accept="image/png, image/jpeg, image/webp, image/gif">
            <button id="attach-btn" class="p-3 rounded-full hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-colors text-light-text-subtle dark:text-dark-text-subtle">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="m21.44 11.05-9.19 9.19a6 6 0 0 1-8.49-8.49l8.57-8.57A4 4 0 1 1 18 8.84l-8.59 8.59a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                </svg>
            </button>
            <textarea id="user-input" rows="1" class="flex-1 bg-transparent py-3 px-4 resize-none focus:outline-none" placeholder="Type your message..." style="max-height: 200px"></textarea>
            <button id="send-btn" class="p-3 rounded-full bg-accent hover:bg-accent-hover text-white disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors">
              <svg id="send-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="19" x2="12" y2="5"></line>
                <polyline points="5 12 12 5 19 12"></polyline>
              </svg>
              <svg id="stop-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden">
                <rect x="6" y="6" width="12" height="12" rx="1"></rect>
              </svg>
              <svg id="save-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                <polyline points="7 3 7 8 15 8"></polyline>
              </svg>
            </button>
          </div>
          <!-- Autocomplete Suggestions -->
          <div id="autocomplete-suggestions" class="absolute bottom-full left-0 w-full mb-2 p-2 rounded-lg shadow-lg bg-light-sidebar dark:bg-dark-sidebar border border-light-border dark:border-dark-border hidden">
            <button id="study-command-btn" class="w-full text-left px-3 py-2 text-sm text-light-text dark:text-dark-text hover:bg-light-border-hover dark:hover:bg-dark-border-hover rounded-md">
                /study - Toggle study mode
            </button>
          </div>
        </div>
      </div>
      <!-- END of the corrected input area -->
    </main>
  </div>

  <div id="settings-modal" class="modal-container">
    <div class="modal-content bg-light-sidebar dark:bg-dark-sidebar p-6 rounded-2xl shadow-xl w-full max-w-md border border-light-border dark:border-dark-border">
      <div class="flex justify-between items-center mb-6">
        <h3 class="text-xl font-semibold">Settings</h3>
        <button id="close-settings-btn" class="p-1 rounded-full hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-colors">
          <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="space-y-6">
        <div class="space-y-2">
          <div>
            <label class="text-sm font-medium text-light-text-subtle dark:text-dark-text-subtle">API Token</label>
            <p class="text-xs text-light-text-subtle dark:text-dark-text-subtle">Your token is stored only in your browser's local storage.</p>
          </div>
          <input id="api-token-input" type="password" class="w-full p-2 rounded-md bg-light-user-bubble dark:bg-dark-user-bubble focus:outline-none focus:ring-2 focus:ring-accent" placeholder="Enter your API token...">
        </div>
        <div class="flex items-center justify-between">
          <label for="pro-models-toggle" class="text-sm font-medium text-light-text-subtle dark:text-dark-text-subtle">Enable Pro Models</label>
          <button id="pro-models-toggle" type="button" class="relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-accent focus:ring-offset-2 bg-gray-200 dark:bg-gray-700" role="switch" aria-checked="false">
            <span aria-hidden="true" class="pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out translate-x-0"></span>
          </button>
        </div>
        <div class="flex items-center justify-between">
          <label for="beta-models-toggle" class="text-sm font-medium text-light-text-subtle dark:text-dark-text-subtle">Enable Beta Models</label>
          <button id="beta-models-toggle" type="button" class="relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-accent focus:ring-offset-2 bg-gray-200 dark:bg-gray-700" role="switch" aria-checked="false">
            <span aria-hidden="true" class="pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out translate-x-0"></span>
          </button>
        </div>
        <div id="font-options"></div>
        <div id="font-weight-options"></div>
        <div class="space-y-2">
          <button id="check-model-status-btn" class="w-full px-4 py-2 rounded-md text-sm font-medium border border-light-border dark:border-dark-border hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-colors">Check Model Availability</button>
          <button id="reset-settings-btn" class="w-full px-4 py-2 rounded-md text-sm font-medium border border-light-border dark:border-dark-border hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-colors">Reset to Default</button>
        </div>
      </div>
    </div>
  </div>
<div id="rename-modal" class="modal-container"><div class="modal-content bg-light-sidebar dark:bg-dark-sidebar p-6 sm:pb-8 rounded-2xl shadow-xl w-full max-w-sm border border-light-border dark:border-dark-border"><h3 class="text-lg font-semibold mb-4">Rename Chat</h3><input id="rename-input" type="text" class="w-full p-2 rounded-md bg-light-user-bubble dark:bg-dark-user-bubble focus:outline-none focus:ring-2 focus:ring-accent mb-4"><div class="flex justify-end gap-2"><button id="rename-cancel" class="px-4 py-2 rounded-md hover:bg-light-border-hover dark:hover:bg-dark-border-hover">Cancel</button><button id="rename-save" class="px-4 py-2 rounded-md bg-accent text-white">Save</button></div></div></div>
  <div id="delete-modal" class="modal-container"><div class="modal-content bg-light-sidebar dark:bg-dark-sidebar p-6 rounded-2xl shadow-xl w-full max-w-sm border border-light-border dark:border-dark-border"><h3 class="text-lg font-semibold mb-4">Delete Chat</h3><p id="delete-message" class="mb-4 text-light-text-subtle dark:text-dark-text-subtle"></p><div class="flex justify-end gap-2"><button id="delete-cancel" class="px-4 py-2 rounded-md hover:bg-light-border-hover dark:hover:bg-dark-border-hover">Cancel</button><button id="delete-confirm" class="px-4 py-2 rounded-md bg-red-600 text-white">Delete</button></div></div></div>
  <div id="signin-modal" class="modal-container">
    <div class="modal-content bg-light-sidebar dark:bg-dark-sidebar p-10 rounded-2xl shadow-xl w-full max-w-md border border-light-border dark:border-dark-border">
        <div class="flex justify-between items-start mb-6">
            <div class="flex border-b border-light-border dark:border-dark-border">
                <button id="signin-tab-btn" class="px-4 py-2 text-lg font-semibold text-accent border-b-2 border-accent">Sign In</button>
                <button id="signup-tab-btn" class="px-4 py-2 text-lg font-semibold text-light-text-subtle dark:text-dark-text-subtle border-b-2 border-transparent">Sign Up</button>
            </div>
            <button id="close-signin-btn" class="p-1 rounded-full hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>
        </div>

        <!-- Sign In View -->
        <div id="signin-view" class="space-y-5">
            <input id="signin-email" type="email" placeholder="Enter your email" class="w-full p-3 rounded-md bg-light-user-bubble dark:bg-dark-user-bubble focus:outline-none focus:ring-2 focus:ring-accent">
            <div class="relative">
                <input id="password-input" type="password" placeholder="Enter your password" class="w-full p-3 pr-10 rounded-md bg-light-user-bubble dark:bg-dark-user-bubble focus:outline-none focus:ring-2 focus:ring-accent">
                <button id="password-toggle-btn" class="absolute inset-y-0 right-0 flex items-center px-3 text-light-text-subtle dark:text-dark-text-subtle">
                    <svg id="eye-open-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"></path><circle cx="12" cy="12" r="3"></circle></svg>
                    <svg id="eye-closed-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M9.9 4.24A9 9 0 0 1 12 3c7 0 10 7 10 7a13.2 13.2 0 0 1-1.67 2.68"></path><path d="M6.61 6.61A13.5 13.5 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"></path><line x1="2" x2="22" y1="2" y2="22"></line><path d="M14 14.25a3 3 0 0 1-4.3-4.3"></path></svg>
                </button>
            </div>
             <a href="#" class="text-xs text-accent hover:underline text-right block -mt-2">Forgot password?</a>
            <button id="signin-email-btn" class="w-full px-4 py-3 rounded-md bg-accent text-white font-semibold hover:bg-accent-hover transition-colors">Sign In</button>
            <div class="flex items-center text-xs text-light-text-subtle dark:text-dark-text-subtle">
                <div class="flex-grow border-t border-light-border dark:border-dark-border"></div>
                <span class="flex-shrink mx-4">OR</span>
                <div class="flex-grow border-t border-light-border dark:border-dark-border"></div>
            </div>
            <button id="signin-google-btn" class="w-full flex items-center justify-center gap-3 px-4 py-3 rounded-md bg-white dark:bg-dark-user-bubble border border-light-border dark:border-dark-border hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-colors font-medium">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l3.66-2.84z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/><path fill="none" d="M1 1h22v22H1z"></svg>
                Continue with Google
            </button>
        </div>

        <!-- Sign Up View -->
        <div id="signup-view" class="hidden space-y-5">
            <input id="signup-email" type="email" placeholder="Enter your email" class="w-full p-3 rounded-md bg-light-user-bubble dark:bg-dark-user-bubble focus:outline-none focus:ring-2 focus:ring-accent">
            <input id="signup-password" type="password" placeholder="Create a password" class="w-full p-3 rounded-md bg-light-user-bubble dark:bg-dark-user-bubble focus:outline-none focus:ring-2 focus:ring-accent">
            <button id="signup-email-btn" class="w-full px-4 py-3 rounded-md bg-accent text-white font-semibold hover:bg-accent-hover transition-colors">Continue with Email</button>
            <div class="flex items-center text-xs text-light-text-subtle dark:text-dark-text-subtle">
                <div class="flex-grow border-t border-light-border dark:border-dark-border"></div>
                <span class="flex-shrink mx-4">OR</span>
                <div class="flex-grow border-t border-light-border dark:border-dark-border"></div>
            </div>
            <button id="signup-google-btn" class="w-full flex items-center justify-center gap-3 px-4 py-3 rounded-md bg-white dark:bg-dark-user-bubble border border-light-border dark:border-dark-border hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-colors font-medium">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l3.66-2.84z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/><path fill="none" d="M1 1h22v22H1z"></svg>
                Continue with Google
            </button>
        </div>
    </div>
</div>
  <div id="chat-actions-dropdown" class="w-32 bg-light-sidebar dark:bg-dark-sidebar rounded-lg shadow-lg border border-light-border dark:border-dark-border"></div>
  
  <!-- Model Availability Modal -->
  <div id="model-availability-modal" class="modal-container">
    <div class="modal-content bg-light-sidebar dark:bg-dark-sidebar p-6 rounded-2xl shadow-xl w-full max-w-2xl max-h-[80vh] overflow-y-auto border border-light-border dark:border-dark-border">
      <div class="flex justify-between items-center mb-6">
        <h3 class="text-xl font-semibold">Model Availability Status</h3>
        <button id="close-model-availability-btn" class="p-1 rounded-full hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-colors">
          <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div id="model-availability-content" class="space-y-2">
        <div class="text-center py-8">
          <div class="loading-spinner mx-auto"></div>
          <p class="mt-2 text-sm text-light-text-subtle dark:text-dark-text-subtle">Checking model availability...</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    const API_BASE_URL = 'https://fronix-html.onrender.com'; // Official Render server URL = https://fronix-html.onrender.com
    const config = { API_ENDPOINT: 'https://text.pollinations.ai/openai' };
    const SUPABASE_URL = 'https://dfrlmrplshijbosawpms.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRmcmxtcnBsc2hpamJvc2F3cG1zIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMyNzEzMDYsImV4cCI6MjA2ODg0NzMwNn0.BzsC5u2LGbq3QydQCAKnIiJvrRHTdjx3HzNGdCzf_ac';
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    
    // Token validation utility functions
    function isTokenExpired(token) {
        if (!token) return true;
        
        try {
            // Parse JWT token to check expiration
            const payload = JSON.parse(atob(token.split('.')[1]));
            const currentTime = Math.floor(Date.now() / 1000);
            
            // Check if token is expired (with 30 second buffer)
            return payload.exp && (payload.exp - 30) < currentTime;
        } catch (error) {
            console.warn("Invalid token format:", error);
            return true; // Consider invalid tokens as expired
        }
    }

    function serializeMessageContent(content) {
        if (content == null) {
            return '';
        }
        if (typeof content === 'string') {
            return content;
        }
        try {
            return JSON.stringify(content);
        } catch (error) {
            console.error('Failed to serialize message content:', error);
            return String(content);
        }
    }

    function cloneStructured(value) {
        if (value == null) return value;
        if (typeof structuredClone === 'function') {
            try {
                return structuredClone(value);
            } catch (error) {
                console.warn('structuredClone failed, falling back to JSON clone.', error);
            }
        }
        try {
            return JSON.parse(JSON.stringify(value));
        } catch (error) {
            console.warn('JSON clone failed, returning original reference.', error);
            return value;
        }
    }

    function parseMessageContentForAI(content) {
        if (content == null) {
            return '';
        }

        if (typeof content === 'string') {
            const trimmed = content.trim();
            const looksJson = (trimmed.startsWith('{') && trimmed.endsWith('}')) ||
                (trimmed.startsWith('[') && trimmed.endsWith(']'));

            if (looksJson) {
                try {
                    return JSON.parse(trimmed);
                } catch (error) {
                    console.warn('Failed to parse message content JSON, sending raw string.', error);
                    return content;
                }
            }

            return content;
        }

        if (typeof content === 'object') {
            return cloneStructured(content);
        }

        return String(content);
    }

    function prepareMessagesForAI(chat, { excludeMessageId = null, includeSystemPrompt = true } = {}) {
        const preparedMessages = [];
        const sourceMessages = Array.isArray(chat?.messages) ? chat.messages : [];

        const hasSystemMessage = sourceMessages.some(message => message?.role === 'system');

        if (includeSystemPrompt && !hasSystemMessage) {
            preparedMessages.push(cloneStructured(SYSTEM_PROMPT));
        }

        if (chat?.study_mode && STUDY_MODE_PROMPT) {
            preparedMessages.push(cloneStructured(STUDY_MODE_PROMPT));
        }

        sourceMessages.forEach((message) => {
            if (!message || !message.role) return;
            if (message.id && message.id === excludeMessageId) return;
            if (!['user', 'assistant', 'system'].includes(message.role)) return;

            const normalizedContent = parseMessageContentForAI(message.content);

            if (message.role === 'assistant' && typeof normalizedContent === 'string' && normalizedContent === '...') {
                return;
            }

            preparedMessages.push({
                role: message.role,
                content: normalizedContent
            });
        });

        return preparedMessages;
    }

    async function saveMessagesToServer(chatId, userMessage, assistantMessage, token) {
        if (!chatId || !token || !userMessage || !assistantMessage) {
            return;
        }

        try {
            const payload = {
                userMessage: {
                    role: userMessage.role,
                    content: serializeMessageContent(userMessage.content)
                },
                assistantMessage: {
                    role: assistantMessage.role,
                    content: serializeMessageContent(assistantMessage.content)
                }
            };

            const response = await fetch(`${API_BASE_URL}/api/chat/${chatId}/save-messages`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Failed to save messages (HTTP ${response.status})`);
            }

            console.log(`[saveMessagesToServer] Conversation saved for chat ${chatId}`);
        } catch (error) {
            console.error('[saveMessagesToServer] Error saving messages:', error);
        }
    }
    
    function scheduleTokenRefresh(token) {
        if (tokenRefreshTimeout) {
            clearTimeout(tokenRefreshTimeout);
            tokenRefreshTimeout = null;
        }

        if (!token) return;

        try {
            const payload = JSON.parse(atob(token.split('.')[1] || ''));
            if (!payload.exp) return;
            const refreshTime = payload.exp * 1000 - Date.now() - (2 * 60 * 1000); // 2 minutes before expiry
            if (refreshTime <= 0) {
                tokenRefreshTimeout = setTimeout(() => refreshAuthSession(), 5000);
            } else {
                tokenRefreshTimeout = setTimeout(() => refreshAuthSession(), refreshTime);
            }
        } catch (error) {
            console.warn('Failed to schedule token refresh:', error);
        }
    }

    async function refreshAuthSession() {
        await validateAndRefreshToken(true);
    }

    async function validateAndRefreshToken(forceRefresh = false) {
        let token = localStorage.getItem('authToken');
        const refreshToken = localStorage.getItem('refreshToken');

        if (!token) {
            return null;
        }

        if (forceRefresh || isTokenExpired(token)) {
            console.log("Access token expired. Attempting to refresh...");
            if (!refreshToken) {
                console.log("No refresh token available. Logging out.");
                localStorage.removeItem('authToken');
                state.currentUser = null;
                updateLoginStateUI();
                return null;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/auth/refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ refreshToken })
                });

                if (!response.ok) {
                    throw new Error('Failed to refresh token');
                }

                const { session } = await response.json();
                localStorage.setItem('authToken', session.access_token);
                localStorage.setItem('refreshToken', session.refresh_token);
                token = session.access_token;
                console.log("Token refreshed successfully.");
                scheduleTokenRefresh(token);
            } catch (error) {
                console.error("Failed to refresh token:", error);
                localStorage.removeItem('authToken');
                localStorage.removeItem('refreshToken');
                state.currentUser = null;
                updateLoginStateUI();
                return null;
            }
        } else {
            scheduleTokenRefresh(token);
        }

        return token;
    }
    
    // --- CORRECTED Sign In Function ---
async function handleSignIn(email, password, retryCount = 0) {
    if (!email || !password) {
        showAlert("Please enter both your email and password.", 'warning');
        return;
    }
    
    const signinBtn = document.getElementById('signin-email-btn');
    const originalText = 'Sign In';
    const maxRetries = 2;
    
    // Show loading state
    setButtonLoading(signinBtn, true, originalText);
    
    try {
        // This function CORRECTLY calls your backend, not the client library.
        const response = await fetch(`${API_BASE_URL}/api/auth/signin`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email, password })
        });
        const data = await response.json();
        if (!response.ok) {
            throw new Error(data.error || 'Unknown sign-in error');
        }
        // The onAuthStateChange listener will detect the login and handle the rest.
        // We manually set the token to speed up the process.
        localStorage.setItem('authToken', data.session.access_token);
        localStorage.setItem('refreshToken', data.session.refresh_token);
        
        // Update UI immediately for instant feedback
        state.currentUser = { email: email }; // Set minimal user info immediately
        updateLoginStateUI();
        closeAllModals();
        showAlert('Sign in successful! Welcome back.', 'success');
        
        // Load full data in background
        loadDataFromServer();
    } catch (error) {
        console.error("Sign-in failed:", error);
        // Retry logic for network/fetch errors
        if (retryCount < maxRetries && (error.message.includes('fetch failed') || error.message.includes('network'))) {
            console.log(`Retrying sign-in attempt ${retryCount + 1}/${maxRetries + 1}...`);
            showAlert(`Connection failed. Retrying... (${retryCount + 1}/${maxRetries + 1})`, 'info', 2000);
            setTimeout(() => {
                handleSignIn(email, password, retryCount + 1);
            }, 1000 * (retryCount + 1)); // Exponential backoff: 1s, 2s
            return; // Don't reset loading state yet
        } else {
            showAlert('Error signing in: ' + error.message, 'error');
        }
    } finally {
        // Reset loading state
        setButtonLoading(signinBtn, false, originalText);
    }
};

    // --- CORRECTED Sign Up Function ---
async function handleSignUp(email, password) {
    if (!email || !password) {
        showAlert("Please provide both an email and a password.", 'warning');
        return;
    }
    if (password.length < 6) {
        showAlert("Password must be at least 6 characters long.", 'warning');
        return;
    }
    
    const signupBtn = document.getElementById('signup-email-btn');
    const originalText = 'Continue with Email';
    
    // Show loading state
    setButtonLoading(signupBtn, true, originalText);
    
    try {
        // This function CORRECTLY calls your backend.
        const response = await fetch(`${API_BASE_URL}/api/auth/signup`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email, password })
        });
        const data = await response.json();
        if (!response.ok) {
            throw new Error(data.error || 'Unknown sign-up error');
        }
        showAlert('Sign-up successful! Please check your email for verification.', 'success');
        closeAllModals();
    } catch (error) {
        console.error("Sign-up failed:", error);
        showAlert('Error signing up: ' + error.message, 'error');
    } finally {
        // Reset loading state
        setButtonLoading(signupBtn, false, originalText);
    }
}

    async function handleGoogleLogin() {
        const signinGoogleBtn = document.getElementById('signin-google-btn');
        const signupGoogleBtn = document.getElementById('signup-google-btn');
        const originalSigninText = 'Continue with Google';
        const originalSignupText = 'Continue with Google';
        
        // Show loading state on both buttons
        setButtonLoading(signinGoogleBtn, true, originalSigninText);
        setButtonLoading(signupGoogleBtn, true, originalSignupText);
        
        try {
            const { error } = await supabaseClient.auth.signInWithOAuth({
                provider: 'google',
                options: {
                    redirectTo: `${API_BASE_URL}/api/auth/callback`
                }
            });
            if (error) {
                throw new Error('Supabase Google login failed: ' + error.message);
            }
            // Don't reset loading state here as user will be redirected
        } catch (error) {
            console.error("Error during Google login:", error);
            showAlert('Google login failed: ' + error.message, 'error');
            // Reset loading state on error
            setButtonLoading(signinGoogleBtn, false, originalSigninText);
            setButtonLoading(signupGoogleBtn, false, originalSignupText);
        }
    }
// --- REPLACE your handleLogout function with this final version ---
async function handleLogout() {
    try {
        // Use the Supabase client to sign out.
        // This will automatically trigger the 'SIGNED_OUT' event
        // in your onAuthStateChange listener, which handles all the UI cleanup.
        const { error } = await supabaseClient.auth.signOut();
        if (error) {
            throw new Error("Logout failed: " + error.message);
        }
    } catch (error) {
        console.error(error);
        // Alert the user even if the sign-out fails, as the local state
        // will be cleared by the listener regardless.
        showAlert('Logout failed: ' + error.message, 'error');
    }
}
function updateProfileUI() {
    if (state.currentUser) {
        elements.profileUsername.textContent = state.currentUser.username || 'User';
        elements.profileEmail.textContent = state.currentUser.email;
        elements.profilePlan.textContent = state.currentUser.plan || 'basic';
        elements.profileBtnUsername.textContent = state.currentUser.username || 'User';
    }
}

async function updateLoginStateUI() {
    if (state.currentUser) {
        elements.signinBtn.classList.add('hidden');
        elements.profileSection.classList.remove('hidden');
        elements.logoutBtn.classList.remove('hidden');
    } else {
        elements.signinBtn.classList.remove('hidden');
        elements.profileSection.classList.add('hidden');
        elements.logoutBtn.classList.add('hidden');
    }
}

// Utility function for retry mechanism with exponential backoff
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return await fn();
        } catch (error) {
            const isLastAttempt = attempt === maxRetries;
            const isNetworkError = error.message.includes('fetch') || error.message.includes('network') || error.message.includes('Failed to fetch');
            const isServerError = error.status >= 500;
            const shouldRetry = !isLastAttempt && (isNetworkError || isServerError);
            
            if (shouldRetry) {
                const delay = baseDelay * Math.pow(2, attempt - 1); // Exponential backoff
                console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`, error.message);
                await new Promise(resolve => setTimeout(resolve, delay));
            } else {
                throw error;
            }
        }
    }
}

async function loadDataFromServer(retryCount = 0, silentLoad = false) {
    const maxRetries = 3;
    const token = localStorage.getItem('authToken');
    if (!token) {
        updateLoginStateUI();
        return;
    }
    
    // Show sync indicator for all loads
    if (!silentLoad || state.chats.length === 0) {
        showSyncIndicator();
    }

    try {
        // Wrap the entire data loading process in retry mechanism
        await retryWithBackoff(async () => {
            // Fetch user info and chats in parallel for speed
            const [userResponse, chatsResponse] = await Promise.all([
                fetch(`${API_BASE_URL}/api/user/me`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                }),
                fetch(`${API_BASE_URL}/api/chat`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                })
            ]);
            
            // Check user response
            if (userResponse.status === 401 || userResponse.status === 403) {
                throw new Error('AUTH_ERROR');
            }
            if (!userResponse.ok) {
                const error = new Error(`Failed to fetch user data. Status: ${userResponse.status}`);
                error.status = userResponse.status;
                throw error;
            }
            state.currentUser = await userResponse.json();
            
            // Update UI immediately after getting user data
            updateLoginStateUI();
            updateProfileUI();

            // Check chats response
            if (chatsResponse.status === 401 || chatsResponse.status === 403) {
                throw new Error('AUTH_ERROR');
            }
            if (!chatsResponse.ok) {
                const error = new Error(`Failed to fetch chats. Status: ${chatsResponse.status}`);
                error.status = chatsResponse.status;
                throw error;
            }
            const chats = await chatsResponse.json();
            state.chats = chats; // Store all chats
            
            // Render sidebar immediately with chat list (even without messages)
            if (!silentLoad) {
                renderSidebar();
            }

            // Fetch messages for all chats in parallel (limit to 5 concurrent requests)
            const messagePromises = [];
            const batchSize = 5;
            
            for (let i = 0; i < state.chats.length; i += batchSize) {
                const batch = state.chats.slice(i, i + batchSize).map(async (chat) => {
                    try {
                        const messagesResponse = await fetch(`${API_BASE_URL}/api/chat/${chat.id}/messages`, {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });
                        
                        if (messagesResponse.status === 401 || messagesResponse.status === 403) {
                            throw new Error('AUTH_ERROR');
                        }
                        if (messagesResponse.ok) {
                            const messages = await messagesResponse.json();
                            chat.messages = Array.isArray(messages.messages) ? messages.messages : [];
                        } else {
                            console.warn(`Failed to fetch messages for chat ${chat.id}`);
                            chat.messages = [];
                        }
                    } catch (error) {
                        console.warn(`Error fetching messages for chat ${chat.id}:`, error);
                        chat.messages = [];
                    }
                });
                
                // Wait for this batch to complete before starting next batch
                await Promise.all(batch);
            }

            // Set active chat based on persisted ID or default to the first chat
            const currentActiveIdBeforeLoad = state.activeId; // Store current activeId
            const lastActiveChatIdFromLocalStorage = localStorage.getItem('lastActiveChatId');

            let newActiveId = null;

            // Priority 1: If current activeId exists and is in the newly fetched chats
            if (currentActiveIdBeforeLoad && state.chats.some(chat => chat.id === currentActiveIdBeforeLoad)) {
                newActiveId = currentActiveIdBeforeLoad;
            }
            // Priority 2: If no current activeId, or current activeId not found, try localStorage
            else if (lastActiveChatIdFromLocalStorage && state.chats.some(chat => chat.id === lastActiveChatIdFromLocalStorage)) {
                newActiveId = lastActiveChatIdFromLocalStorage;
            }
            // Priority 3: If neither, default to the first chat
            else if (state.chats.length > 0) {
                newActiveId = state.chats[0].id;
            }

            if (newActiveId !== null) {
                state.activeId = newActiveId;
            } else {
                // If no chats exist, create a new one
                await handleNewChat();
                return; // handleNewChat will set activeId and render
            }
        });

        // If we get here, everything succeeded
        console.log('[loadDataFromServer] Data loaded successfully. Current state.chats:', JSON.parse(JSON.stringify(state.chats))); // Deep copy for logging
        console.log('[loadDataFromServer] Current state.activeId:', state.activeId);
        
        // Save to cache for instant future loads
        saveState();
        
        // Only re-render if not a silent load to avoid UI flicker
        if (!silentLoad) {
            renderSidebar();
            renderChat();
        } else {
            console.log('[loadDataFromServer] Silent load - updated cache without re-rendering');
        }

    } catch (error) {
        console.error("[loadDataFromServer] Error loading data from server:", error);
        
        // Only clear token and sign out on authentication errors
        if (error.message === 'AUTH_ERROR') {
            showAlert('Your session has expired. Please sign in again.', 'warning');
            localStorage.removeItem('authToken');
            state.currentUser = null;
        } else {
            // For network/server errors, just show a warning but keep user signed in
            console.warn('[loadDataFromServer] Temporary network issue:', error.message);
            // Don't alert for temporary issues, just log them
        }
    } finally {
        hideSyncIndicator();
        updateLoginStateUI();
        updateProfileUI();
        console.log('[loadDataFromServer] Finished. Final state.activeId:', state.activeId);
    }
}
// ++ ADD THIS NEW FUNCTION TO YOUR SCRIPT ++
async function handleNewChat() {
    const token = localStorage.getItem('authToken');
    const isAnonymous = !token;
    if (isAnonymous) {
        showAlert("Creating a local chat (anonymous mode). Sign in to sync across devices.", 'info');
    }

    // Create a new chat object with appropriate ID
    const chatId = isAnonymous ? `anon-${Date.now()}` : `temp-${Date.now()}`;
    const newChat = {
        id: chatId,
        title: 'New Chat',
        messages: [],
        model: isAnonymous ? getFirstAvailableAnonymousModel() : (state.settings.model || 'gpt-4.1'),
        created_at: new Date().toISOString()
    };

    // Add the new chat to the state and set it as active
    console.log('[handleNewChat] Adding new chat:', newChat);
    state.chats.unshift(newChat);
    setActive(chatId);
    renderSidebar(); // Update sidebar immediately
    renderChat(); // Render empty chat immediately
    
    if (isAnonymous) {
        // For anonymous users, save to localStorage and finish
        saveAnonymousChat(newChat);
        saveState();
        console.log('[handleNewChat] Anonymous chat created and saved to localStorage');
        return;
    }

    // For logged-in users, create on server
    saveState();
    console.log('[handleNewChat] State after optimistic add. state.chats:', JSON.parse(JSON.stringify(state.chats))); // Deep copy for logging
    console.log('[handleNewChat] State after optimistic add. state.activeId:', state.activeId);

    try {
        const response = await fetch(`${API_BASE_URL}/api/chat`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({ title: 'New Chat' })
        });

        if (!response.ok) {
            throw new Error('Failed to create chat on server');
        }

        const newChatFromServer = await response.json();
        newChatFromServer.messages = []; // Initialize with an empty messages array

        // Find the optimistically added chat and update its real ID
        const index = state.chats.findIndex(chat => chat.id === chatId);
        if (index !== -1) {
            state.chats[index].id = newChatFromServer.id;
            state.chats[index].created_at = newChatFromServer.created_at; // Update timestamp if needed
            state.activeId = newChatFromServer.id; // Ensure activeId is the real one
        } else {
            // Fallback if optimistic chat not found (shouldn't happen)
            state.chats.unshift(newChatFromServer);
            state.activeId = newChatFromServer.id;
        }
        
        console.log('[handleNewChat] New chat created on server:', newChatFromServer);
        
        renderSidebar(); // Re-render to update ID in sidebar
        saveState(); // Save state with real ID
        console.log('[handleNewChat] State after successful backend save. state.chats:', JSON.parse(JSON.stringify(state.chats))); // Deep copy for logging
        console.log('[handleNewChat] State after successful backend save. state.activeId:', state.activeId);

    } catch (error) {
        console.error("[handleNewChat] Error creating new chat:", error);
        showAlert("Could not create a new chat. Please try again.", 'error');

        // Revert optimistic update on error
        const index = state.chats.findIndex(chat => chat.id === chatId);
        if (index !== -1) {
            state.chats.splice(index, 1); // Remove optimistic chat
            // If the deleted chat was active, set a new active chat
            if (state.activeId === chatId) {
                state.activeId = state.chats.length > 0 ? state.chats[0].id : null;
            }
            renderSidebar(); // Re-render sidebar after removal
            renderChat(); // Re-render chat area
            saveState();
            console.log('[handleNewChat] State after error rollback. state.chats:', JSON.parse(JSON.stringify(state.chats))); // Deep copy for logging
            console.log('[handleNewChat] State after error rollback. state.activeId:', state.activeId);
        }
    }
}

    const SYSTEM_PROMPT = { role: 'system', content: `You are Fronix, a large language model. You are chatting with the user via the Fronix iOS app. This means most of the time your lines should be a sentence or two, unless the user's request requires reasoning or long-form outputs. Never use emojis, unless explicitly asked to. 
Knowledge cutoff: 2024-06
Current date: 2025-05-15

Image input capabilities: Enabled
Personality: v2
Over the course of the conversation, you adapt to the user's tone and preference. Try to match the user's vibe, tone, and generally how they are speaking. You want the conversation to feel natural. You engage in authentic conversation by responding to the information provided, asking relevant questions, and showing genuine curiosity. If natural, continue the conversation with casual conversation.
`};
    const STUDY_MODE_PROMPT = {
        role: 'system',
        content: `Let's discuss a topic or concept that I'm curious about, and you'll ask me questions to help me explore it further. We'll work together to build a deep understanding of the topic, and you'll provide feedback to help me identify any misconceptions or gaps in my understanding, sort of like the Feynman technique. We'll approach this with an open mind, and we'll be curious and inquisitive as we explore the topic.
I want you to keep in mind that you do also ask specific questions that will push my understanding of said topic, it doesn't matter if I'm not capable of answering cause my goal is to learn more and more. Let's begin.`
    };
    const MODELS = {
      // Text Models - Anonymous (Pollinations.ai)
      'gpt-4.1': { name: 'OpenAI GPT-4.1', type: 'text', anonymous: true },
      'gpt-5-nano': { name: 'OpenAI GPT-5 Nano', type: 'text', anonymous: true },
      'gemini': { name: 'Gemini 2.5 Flash Lite', type: 'text', anonymous: true },

      // Text Models - Pollinations.ai direct models
      'deepseek-reasoning': { name: 'DeepSeek R1 0528 (Bedrock)', type: 'text' },
      'openai-reasoning': { name: 'OpenAI o4', type: 'text' },

      // A4F.co models (provider-prefixed)
      
      'provider-1/glm-4.5-fp8': { name: 'GLM 4.5', type: 'text' },
      'provider-1/glm-4.5-air-fp8': { name: 'GLM 4.5 Air', type: 'text' },

      // Pro Models
      'grok-4': { name: 'Grok 4', type: 'text', pro: true },
      'gpt-5': { name: 'GPT-5', type: 'text', pro: true },
      'gemini-2.5-pro': { name: 'Gemini 2.5 Pro', type: 'text', pro: true },
      'gemini-2.5-flash': { name: 'Gemini 2.5 Flash', type: 'text', pro: true },

      // Image Generation Models
 
      'pollinations-flux': { name: 'Flux', type: 'image', provider: 'pollinations' },
      'pollinations-kontext': { name: 'Flux Kontext (Image-to-Image)', type: 'image', provider: 'pollinations' },
      'nanobanana': { name: 'NanoBanana', type: 'image', provider: 'pollinations' },
      'seedream': { name: 'SeeDream', type: 'image', provider: 'pollinations' },

      // Image Editing Models (A4F.co)
      'provider-4/qwen-image': { name: 'Qwen Image Editor', type: 'image-edit', provider: 'a4f' }
    };
    
    // Model availability status (updated from server)
    let modelAvailability = {};

    const elements = {
      body: document.body, sidebar: document.getElementById('sidebar'), sidebarOverlay: document.getElementById('sidebar-overlay'), chatList: document.getElementById('chat-list'), chatBox: document.getElementById('chat-box'), chatTitle: document.getElementById('chat-title'), userInput: document.getElementById('user-input'), sendBtn: document.getElementById('send-btn'), sendIcon: document.getElementById('send-icon'), stopIcon: document.getElementById('stop-icon'), saveIcon: document.getElementById('save-icon'), newChatBtn: document.getElementById('new-chat'), toggleSidebarBtn: document.getElementById('toggle-sidebar'), themeToggleBtn: document.getElementById('theme-toggle'), settingsBtn: document.getElementById('settings-btn'),
      signinBtn: document.getElementById('signin-btn'),
      logoutBtn: document.getElementById('logout-btn'),
      profileSection: document.getElementById('profile-section'),
      profileBtn: document.getElementById('profile-btn'),
      profileDropdown: document.getElementById('profile-dropdown'),
      profileUsername: document.getElementById('profile-username'),
      profileEmail: document.getElementById('profile-email'),
      profilePlan: document.getElementById('profile-plan'),
      profileBtnUsername: document.getElementById('profile-btn-username'),
      modelSelector: document.getElementById('model-selector'), modelDropdown: document.getElementById('model-dropdown'),
      chatActionsDropdown: document.getElementById('chat-actions-dropdown'),
      editIndicator: document.getElementById('edit-indicator'),
      cancelEditBtn: document.getElementById('cancel-edit-btn'),
      scrollToBottomBtn: document.getElementById('scroll-to-bottom-btn'), // Added scroll to bottom button
      autocompleteSuggestions: document.getElementById('autocomplete-suggestions'), // Added for autocomplete
      studyCommandBtn: document.getElementById('study-command-btn'), // Added for study command autocomplete
      studyModeIndicator: document.getElementById('study-mode-indicator'), // Added study mode indicator
      syncIndicator: document.getElementById('sync-indicator'), // Added sync indicator
      settingsModal: { container: document.getElementById('settings-modal'), fontOptions: document.getElementById('font-options'), fontWeightOptions: document.getElementById('font-weight-options'), closeBtn: document.getElementById('close-settings-btn'), resetBtn: document.getElementById('reset-settings-btn'), apiTokenInput: document.getElementById('api-token-input'), proModelsToggle: document.getElementById('pro-models-toggle'), betaModelsToggle: document.getElementById('beta-models-toggle'), checkModelStatusBtn: document.getElementById('check-model-status-btn') },
      modelAvailabilityModal: { container: document.getElementById('model-availability-modal'), content: document.getElementById('model-availability-content'), closeBtn: document.getElementById('close-model-availability-btn') },
      renameModal: { container: document.getElementById('rename-modal'), input: document.getElementById('rename-input'), saveBtn: document.getElementById('rename-save'), cancelBtn: document.getElementById('rename-cancel') },
      deleteModal: { container: document.getElementById('delete-modal'), message: document.getElementById('delete-message'), confirmBtn: document.getElementById('delete-confirm'), cancelBtn: document.getElementById('delete-cancel') },
      signinModal: { container: document.getElementById('signin-modal'), closeBtn: document.getElementById('close-signin-btn') },
    };

    let state = { chats: [], activeId: null, editingMessage: null, modalContext: {}, settings: { model: 'gpt-4.1', font: 'inter', fontWeight: '400', apiToken: '', proModelsEnabled: false, betaModelsEnabled: false }, currentUser: null };
    let currentController = null; // For aborting fetch requests
    let isStreaming = false; // Flag to indicate if streaming is active
    let isScrolledUp = false; // Flag to indicate if the user has scrolled up
    let isGeneratingTitle = false; // Flag to indicate if title generation is in progress
    let attachedImageData = null; // To store { file?, dataUrl, previewUrl }

    const STREAM_ERROR_TARGET_MESSAGE = 'An error occurred while streaming the response from the model provider.';
    const STREAM_ERROR_MAX_RETRIES = 2; // Total attempts = initial try + 2 retries
    const STREAM_ERROR_RETRY_DELAY_MS = 800;

    function isRetryableStreamError(message) {
        return typeof message === 'string' && message.includes(STREAM_ERROR_TARGET_MESSAGE);
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function setStreamingUIState(isActive) {
        if (!elements.sendIcon || !elements.stopIcon || !elements.sendBtn) {
            updateSendButtonState();
            return;
        }

        if (isActive) {
            elements.sendIcon.classList.add('hidden');
            elements.stopIcon.classList.remove('hidden');
            elements.sendBtn.classList.remove('bg-accent', 'hover:bg-accent-hover');
            elements.sendBtn.classList.add('bg-red-600', 'hover:bg-red-700');
        } else {
            elements.sendIcon.classList.remove('hidden');
            elements.stopIcon.classList.add('hidden');
            elements.sendBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
            elements.sendBtn.classList.add('bg-accent', 'hover:bg-accent-hover');
        }
        updateSendButtonState();
    }
    let attachmentDownloadPromise = null;
    let isAttachmentLoading = false;
    let tokenRefreshTimeout = null;

    function clearAttachedImage(resetPreview = true) {
        attachedImageData = null;
        attachmentDownloadPromise = null;
        isAttachmentLoading = false;
        const imageUpload = document.getElementById('image-upload');
        if (imageUpload) {
            imageUpload.value = null;
        }
        if (resetPreview) {
            hideImagePreview();
        }
        updateSendButtonState();
    }

    function hideImagePreview() {
        const imagePreviewContainer = document.getElementById('image-preview-container');
        if (!imagePreviewContainer) return;
        imagePreviewContainer.innerHTML = '';
        imagePreviewContainer.classList.add('hidden');
    }

    function imagePreviewContainerHasContent() {
        const imagePreviewContainer = document.getElementById('image-preview-container');
        if (!imagePreviewContainer) return false;
        return imagePreviewContainer.innerHTML.trim() !== '' && !imagePreviewContainer.classList.contains('hidden');
    }

    function renderImagePreview(imageUrl) {
        const imagePreviewContainer = document.getElementById('image-preview-container');
        if (!imagePreviewContainer) return;

        imagePreviewContainer.innerHTML = `
            <div class="relative inline-block">
                <img src="${imageUrl}" class="h-20 w-20 object-cover rounded-lg">
                <button id="remove-image-btn" class="absolute top-0 right-0 -mt-2 -mr-2 bg-red-500 text-white rounded-full p-1 leading-none" title="Remove image">
                    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
        `;
        imagePreviewContainer.classList.remove('hidden');

        const removeBtn = document.getElementById('remove-image-btn');
        if (removeBtn) {
            removeBtn.onclick = () => clearAttachedImage();
        }
        updateSendButtonState();
    }

    async function fetchImageAsDataUrl(imageUrl) {
        const response = await fetch(imageUrl, { mode: 'cors' });
        if (!response.ok) {
            throw new Error(`Failed to fetch image (HTTP ${response.status})`);
        }
        const blob = await response.blob();
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(reader.error);
            reader.readAsDataURL(blob);
        });
    }

    async function attachImageFromUrl(imageUrl) {
        if (!imageUrl) return;
        if (isAttachmentLoading) {
            showAlert('Still preparing your previous image. Please wait.', 'info', 2000);
            return;
        }
        const loadingPreviewContainer = document.getElementById('image-preview-container');
        if (loadingPreviewContainer) {
            loadingPreviewContainer.innerHTML = `
                <div class="relative inline-flex h-20 w-20 items-center justify-center rounded-lg border border-light-border dark:border-dark-border bg-light-border/30 dark:bg-dark-border/30">
                    <div class="loading-spinner w-6 h-6"></div>
                </div>
            `;
            loadingPreviewContainer.classList.remove('hidden');
        }

        try {
            const cacheBustingUrl = imageUrl + (imageUrl.includes('?') ? '&' : '?') + 't=' + Date.now();
            isAttachmentLoading = true;
            updateSendButtonState();
            attachedImageData = { dataUrl: null, previewUrl: imageUrl, isPending: true };
            attachmentDownloadPromise = fetchImageAsDataUrl(cacheBustingUrl);
            const base64Data = await attachmentDownloadPromise;
            attachedImageData = { dataUrl: base64Data, previewUrl: imageUrl, isPending: false };
            renderImagePreview(imageUrl);

            const imageUpload = document.getElementById('image-upload');
            if (imageUpload) {
                imageUpload.value = null;
            }

            elements.userInput.focus();
            showAlert('Image attached for editing. Add your prompt to refine it.', 'info', 3500);
        } catch (error) {
            console.error('Failed to attach image for editing:', error);
            showAlert('Failed to attach image for editing. Please try again.', 'error', 4000);
            clearAttachedImage();
        } finally {
            attachmentDownloadPromise = null;
            isAttachmentLoading = false;
            updateSendButtonState();
        }
    }

    function bindGeneratedImageEditButtons() {
        const buttons = document.querySelectorAll('.edit-generated-image-btn');
        buttons.forEach(button => {
            if (button.dataset.bound === 'true') return;
            button.dataset.bound = 'true';
            button.addEventListener('click', () => {
                const imageUrl = button.getAttribute('data-image-url');
                attachImageFromUrl(imageUrl);
            });
        });
    }

    function getAttachmentPreviewUrl() {
        if (!attachedImageData) return null;
        return attachedImageData.previewUrl || attachedImageData.dataUrl || null;
    }

    function getAttachmentDataUrl() {
        if (!attachedImageData) return null;
        return attachedImageData.dataUrl || attachedImageData.previewUrl || null;
    }

    // Custom alert system
    function showAlert(message, type = 'info', duration = 5000) {
        const alertContainer = document.createElement('div');
        alertContainer.className = `custom-alert ${type}`;
        
        alertContainer.innerHTML = `
            <div class="alert-content">${message}</div>
            <button class="alert-close" onclick="dismissAlert(this.parentElement)">&times;</button>
        `;
        
        document.body.appendChild(alertContainer);
        
        // Trigger show animation
        setTimeout(() => {
            alertContainer.classList.add('show');
        }, 10);
        
        // Auto dismiss after duration
        if (duration > 0) {
            setTimeout(() => {
                dismissAlert(alertContainer);
            }, duration);
        }
        
        return alertContainer;
    }
    
    function dismissAlert(alertElement) {
        if (alertElement && alertElement.parentElement) {
            alertElement.classList.remove('show');
            setTimeout(() => {
                if (alertElement.parentElement) {
                    alertElement.parentElement.removeChild(alertElement);
                }
            }, 300);
        }
    }
    
    // Button loading state management
    function setButtonLoading(button, loading, originalText) {
        if (loading) {
            button.disabled = true;
            button.innerHTML = `<div class="loading-spinner"></div>${originalText}`;
        } else {
            button.disabled = false;
            button.innerHTML = originalText;
        }
    }
    
    // Sync indicator controls
    function showSyncIndicator() {
        if (elements.syncIndicator) {
            elements.syncIndicator.classList.remove('hidden');
        }
    }
    function hideSyncIndicator() {
        if (elements.syncIndicator) {
            elements.syncIndicator.classList.add('hidden');
        }
    }
    
    // Model availability functions with optimization support
    async function fetchModelAvailability() {
        try {
            showSyncIndicator();
            const response = await fetch(`${API_BASE_URL}/api/ai/model-status`);
            if (response.ok) {
                const data = await response.json();
                modelAvailability = data.status || {};
                console.log('📊 Model availability updated:', modelAvailability);

                // Log optimization statistics if available
                if (data.optimizationEnabled) {
                    console.log('🚀 Network optimization enabled:', data.cacheStats);
                }

                // Update model selection for anonymous users if needed
                updateAnonymousModelSelection();

                renderModelDropdown(); // Update dropdown after availability check
            } else {
                console.warn(`Failed to fetch model availability: HTTP ${response.status}`);
                // Set all models as available by default
                modelAvailability = {};
                Object.keys(MODELS).forEach(key => {
                    modelAvailability[key] = { available: true };
                });
                updateAnonymousModelSelection();
                renderModelDropdown();
            }
        } catch (error) {
            console.warn('Backend server unavailable. Using fallback model configuration:', error.message);
            // Set all models as available by default
            modelAvailability = {};
            Object.keys(MODELS).forEach(key => {
                modelAvailability[key] = { available: true };
            });
            updateAnonymousModelSelection();
            renderModelDropdown();
            // Show user-friendly message only if user is not already signed in
            if (!state.currentUser) {
                showAlert('Some features may be limited. Backend server is not available.', 'warning', 8000);
            }
        } finally {
            hideSyncIndicator();
        }
    }

    // Fetch optimization statistics
    async function fetchOptimizationStats() {
        try {
            const response = await fetch(`${API_BASE_URL}/api/ai/optimization-stats`);
            if (response.ok) {
                const data = await response.json();
                console.log('📈 Optimization statistics:', data);

                // Show optimization benefits in a notification
                if (data.optimizationFeatures.requestBatching) {
                    showAlert(`🚀 Network optimization active! Using request batching, intelligent caching, and deduplication for faster model checks.`, 'info', 5000);
                }

                return data;
            } else {
                console.warn(`Failed to fetch optimization stats: HTTP ${response.status}`);
                return null;
            }
        } catch (error) {
            console.warn('Could not fetch optimization statistics:', error.message);
            return null;
        }
    }
    
    // Show detailed model availability in modal with live testing
    async function showModelAvailability() {
        animateModalOpen(elements.modelAvailabilityModal.container);
        
        // Initially show loading state
        elements.modelAvailabilityModal.content.innerHTML = `
            <div class="text-center py-8">
                <div class="loading-spinner mx-auto"></div>
                <p class="mt-2 text-sm text-light-text-subtle dark:text-dark-text-subtle">Sending test messages to models...</p>
            </div>
        `;
        
        try {
            const response = await fetch(`${API_BASE_URL}/api/ai/model-status`);
            if (response.ok) {
                const data = await response.json();
                const status = data.status || {};
                
                // Group models by provider
                const modelsByProvider = {};
                
                Object.entries(status).forEach(([modelId, info]) => {
                    const provider = info.provider || 'Unknown';
                    if (!modelsByProvider[provider]) {
                        modelsByProvider[provider] = [];
                    }
                    const modelInfo = MODELS[modelId] || { name: modelId };
                    modelsByProvider[provider].push({
                        id: modelId,
                        name: modelInfo.name,
                        apiName: info.apiName || modelId,
                        available: info.available !== false,
                        response: null,
                        testing: true
                    });
                });
                
                // Render initial UI with all models in testing state
                renderModelAvailabilityUI(modelsByProvider);
                
                // Test each model with a "hi" message
                for (const [provider, models] of Object.entries(modelsByProvider)) {
                    for (const model of models) {
                        testModelWithHello(model.id, model.apiName || model.id).then(response => {
                            model.testing = false;
                            model.response = response;
                            model.available = response.success;
                            renderModelAvailabilityUI(modelsByProvider);
                        }).catch(err => {
                            model.testing = false;
                            model.response = { success: false, message: 'Failed to test' };
                            model.available = false;
                            renderModelAvailabilityUI(modelsByProvider);
                        });
                    }
                }
            } else {
                throw new Error('Failed to fetch model status');
            }
        } catch (error) {
            console.error('Error fetching model availability:', error);
            elements.modelAvailabilityModal.content.innerHTML = `
                <div class="text-center py-8">
                    <p class="text-red-500">Failed to fetch model availability</p>
                    <p class="text-sm text-light-text-subtle dark:text-dark-text-subtle mt-2">${error.message}</p>
                </div>
            `;
        }
    }

    // Update progress during testing
    function updateModelAvailabilityProgress(completed, total) {
        const progressPercent = Math.round((completed / total) * 100);
        const progressHtml = `
            <div class="space-y-3">
                <div class="flex items-center justify-between">
                    <span class="text-sm text-light-text-subtle dark:text-dark-text-subtle">
                        Testing models... (${completed}/${total})
                    </span>
                    <span class="text-sm font-medium text-accent">${progressPercent}%</span>
                </div>
                <div class="w-full bg-light-border dark:bg-dark-border rounded-full h-2">
                    <div class="bg-accent h-2 rounded-full transition-all duration-300" style="width: ${progressPercent}%"></div>
                </div>
            </div>
        `;

        const existingContent = elements.modelAvailabilityModal.content.innerHTML;
        elements.modelAvailabilityModal.content.innerHTML = existingContent.replace(
            /<div class="space-y-3">[\s\S]*?<\/div>/,
            progressHtml
        );
    }

    // Render final test results with improved UI
    function renderModelAvailabilityResults(results) {
        let html = '<div class="p-6"><h3 class="text-lg font-semibold mb-4 text-light-text dark:text-dark-text">Model Availability Results</h3>';

        Object.entries(results).forEach(([provider, models]) => {
            html += `<div class="mb-6"><h4 class="text-md font-medium mb-3 text-light-text dark:text-dark-text">${provider}</h4>`;

            models.forEach(({ key, data, result }) => {
                const isSuccess = result.success;
                const statusIcon = isSuccess ?
                    '<svg class="w-5 h-5 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>' :
                    '<svg class="w-5 h-5 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>';

                const badges = [];
                if (data.pro) badges.push('<span class="px-2 py-1 bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-200 rounded text-xs">PRO</span>');
                if (data.beta) badges.push('<span class="px-2 py-1 bg-purple-100 dark:bg-purple-900/30 text-purple-800 dark:text-purple-200 rounded text-xs">BETA</span>');
                if (data.anonymous) badges.push('<span class="px-2 py-1 bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-200 rounded text-xs">FREE</span>');

                html += `
                    <div class="flex items-center justify-between p-3 bg-light-border-hover dark:bg-dark-border-hover rounded-lg mb-2">
                        <div class="flex items-center gap-3 flex-1">
                            ${statusIcon}
                            <div class="flex-1">
                                <div class="font-medium text-sm">${data.name}</div>
                                <div class="text-xs text-light-text-subtle dark:text-dark-text-subtle">
                                    ${result.message} ${result.responseTime > 0 ? `(${result.responseTime}ms)` : ''}
                                </div>
                            </div>
                            <div class="flex gap-1">
                                ${badges.join('')}
                            </div>
                        </div>
                    </div>
                `;
            });

            html += '</div>';
        });

        html += `
            <div class="mt-6 pt-4 border-t border-light-border dark:border-dark-border">
                <div class="flex items-center justify-between text-sm text-light-text-subtle dark:text-dark-text-subtle">
                    <span>Tests cached for 5 minutes</span>
                    <button onclick="showModelAvailability()" class="px-3 py-1 bg-accent hover:bg-accent-hover text-white rounded text-xs transition-colors">
                        Refresh
                    </button>
                </div>
            </div>
        </div>`;

        elements.modelAvailabilityModal.content.innerHTML = html;
    }

    // Clean up when modal is closed
    function closeModelAvailabilityModal() {
        modelTester.cleanup();
        animateModalClose(elements.modelAvailabilityModal.container);
    }
    
    // Enhanced Model Tester Class with proper cleanup and retry logic
    class ModelTester {
        constructor() {
            this.controllers = new Map();
            this.activeTests = new Map();
            this.testResults = new Map();
        }

        // Test a model with retry logic and proper cleanup
        async testModelWithRetry(modelId, apiName, maxRetries = 2) {
            const testKey = `${modelId}-${apiName}`;

            // Check if test is already running
            if (this.activeTests.has(testKey)) {
                return this.activeTests.get(testKey);
            }

            const testPromise = this._testModelWithRetryInternal(modelId, apiName, maxRetries);
            this.activeTests.set(testKey, testPromise);

            try {
                const result = await testPromise;
                return result;
            } finally {
                this.activeTests.delete(testKey);
            }
        }

        async _testModelWithRetryInternal(modelId, apiName, maxRetries) {
            let lastError;

            for (let attempt = 0; attempt <= maxRetries; attempt++) {
                try {
                    const result = await this.testModelWithTimeout(modelId, apiName);
                    this.testResults.set(`${modelId}-${apiName}`, {
                        ...result,
                        timestamp: Date.now()
                    });
                    return result;
                } catch (error) {
                    lastError = error;
                    console.warn(`[ModelTester] Attempt ${attempt + 1} failed for ${modelId}:`, error.message);

                    if (attempt < maxRetries) {
                        // Exponential backoff: 1s, 2s, 4s
                        const delay = Math.pow(2, attempt) * 1000;
                        await this.delay(delay);
                    }
                }
            }

            // All retries failed
            return {
                success: false,
                message: `Failed after ${maxRetries + 1} attempts: ${lastError?.message || 'Unknown error'}`,
                error: lastError
            };
        }

        async testModelWithTimeout(modelId, apiName, timeoutMs = 10000) {
            return new Promise(async (resolve, reject) => {
                const controller = new AbortController();
                const timeout = setTimeout(() => {
                    controller.abort();
                    reject(new Error('Test timeout'));
                }, timeoutMs);

                this.controllers.set(`${modelId}-${apiName}`, controller);

                try {
                    const result = await this._testModelOnce(modelId, apiName, controller);
                    clearTimeout(timeout);
                    resolve(result);
                } catch (error) {
                    clearTimeout(timeout);
                    reject(error);
                } finally {
                    this.controllers.delete(`${modelId}-${apiName}`);
                }
            });
        }

        async _testModelOnce(modelId, apiName, controller) {
            const isImageModel = MODELS[modelId]?.type === 'image' || MODELS[modelId]?.type === 'image-edit';

            try {
                if (isImageModel) {
                    // For image models, we'll just check if they're configured
                    return {
                        success: true,
                        message: 'Image model ready',
                        responseTime: 50,
                        timestamp: Date.now()
                    };
                }

                // Test text models with a simple message
                const token = state.settings.apiToken || localStorage.getItem('authToken');
                const endpoint = state.currentUser ? `${API_BASE_URL}/api/ai/chat` : `${API_BASE_URL}/api/ai/chat-public`;
                const startTime = Date.now();

                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(token && state.currentUser ? { 'Authorization': `Bearer ${token}` } : {})
                    },
                    body: JSON.stringify({
                        model: modelId,
                        messages: [{ role: 'user', content: 'hi' }]
                    }),
                    signal: controller.signal
                });

                const responseTime = Date.now() - startTime;

                if (response.ok) {
                    // Try to read response to verify it's working
                    try {
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let responseText = '';
                        let hasContent = false;

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            const chunk = decoder.decode(value);
                            responseText += chunk;

                            // Look for content in the stream
                            const matches = chunk.match(/"content":"([^"]+)"/g);
                            if (matches && matches.length > 0) {
                                hasContent = true;
                                const content = matches[0].replace(/"content":"/, '').replace(/"$/, '');
                                return {
                                    success: true,
                                    message: content.substring(0, 30) + '...',
                                    responseTime,
                                    timestamp: Date.now()
                                };
                            }

                            // Stop after getting enough data or taking too long
                            if (responseText.length > 500 || (Date.now() - startTime) > 8000) break;
                        }

                        return {
                            success: true,
                            message: hasContent ? 'Responding...' : 'Connected successfully',
                            responseTime,
                            timestamp: Date.now()
                        };
                    } catch (streamError) {
                        return {
                            success: true,
                            message: 'Connected successfully',
                            responseTime,
                            timestamp: Date.now()
                        };
                    }
                } else {
                    const errorText = await response.text().catch(() => 'Unknown error');
                    return {
                        success: false,
                        message: `HTTP ${response.status}: ${response.statusText}`,
                        responseTime,
                        timestamp: Date.now()
                    };
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    return {
                        success: false,
                        message: 'Test timeout',
                        responseTime: 0,
                        timestamp: Date.now()
                    };
                }

                return {
                    success: false,
                    message: error.message.substring(0, 50),
                    responseTime: 0,
                    timestamp: Date.now()
                };
            }
        }

        // Clean up all active connections
        cleanup() {
            console.log(`[ModelTester] Cleaning up ${this.controllers.size} active connections`);
            this.controllers.forEach((controller, key) => {
                controller.abort();
            });
            this.controllers.clear();
            this.activeTests.clear();
        }

        // Get cached test result
        getCachedResult(modelId, apiName) {
            const key = `${modelId}-${apiName}`;
            const cached = this.testResults.get(key);

            if (cached) {
                // Consider result valid for 5 minutes
                const isValid = (Date.now() - cached.timestamp) < (5 * 60 * 1000);
                if (isValid) {
                    return cached;
                } else {
                    this.testResults.delete(key);
                }
            }

            return null;
        }

        // Utility function for delays
        delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    }

    // Create global model tester instance
    const modelTester = new ModelTester();
    
    // Check if user is anonymous (not logged in)
    function isAnonymousUser() {
        return !state.currentUser;
    }
    
    // Check if model is available for anonymous users
    function isModelAvailableForAnonymous(modelKey) {
        const model = MODELS[modelKey];
        return model && model.anonymous === true;
    }
    
    // Check if model requires login
    function doesModelRequireLogin(modelKey) {
        const model = MODELS[modelKey];
        return model && (model.pro || !model.anonymous) && !state.currentUser;
    }
    
    // Check if model is available (not down)
    function isModelAvailable(modelKey) {
        if (!modelKey) return false;

        const status = modelAvailability?.[modelKey];
        if (status && typeof status.available === 'boolean') {
            return status.available;
        }

        // Default to available if no status has been fetched yet
        return true;
    }
    
    // Save chat to localStorage for anonymous users
    function saveAnonymousChat(chat) {
        try {
            const anonymousChats = JSON.parse(localStorage.getItem('anonymousChats') || '[]');
            const existingIndex = anonymousChats.findIndex(c => c.id === chat.id);
            
            if (existingIndex >= 0) {
                anonymousChats[existingIndex] = chat;
            } else {
                anonymousChats.unshift(chat);
            }
            
            // Keep only last 20 chats to avoid localStorage bloat
            if (anonymousChats.length > 20) {
                anonymousChats.splice(20);
            }
            
            localStorage.setItem('anonymousChats', JSON.stringify(anonymousChats));
            console.log('💾 Anonymous chat saved to localStorage');
        } catch (error) {
            console.warn('Failed to save anonymous chat:', error);
        }
    }
    
    // Load anonymous chats from localStorage
    function loadAnonymousChats() {
        try {
            const anonymousChats = JSON.parse(localStorage.getItem('anonymousChats') || '[]');
            return anonymousChats;
        } catch (error) {
            console.warn('Failed to load anonymous chats:', error);
            return [];
        }
    }
    
    // Get the first available model for anonymous users
    function getFirstAvailableAnonymousModel() {
        const anonymousModels = ['gpt-4.1', 'gpt-5-nano', 'gemini']; // In order of preference

        for (const modelKey of anonymousModels) {
            if (isModelAvailable(modelKey)) {
                console.log(`📍 Selected available anonymous model: ${modelKey}`);
                return modelKey;
            }
        }

        // If no models are available, return the first one anyway (fallback)
        console.warn('⚠️ No anonymous models appear to be available, falling back to first model');
        return anonymousModels[0];
    }
    
    // Update model selection for anonymous users based on availability
    function updateAnonymousModelSelection() {
        if (!isAnonymousUser()) return; // Only for anonymous users
        
        const currentModel = state.settings.model;
        
        // Check if current model is available for anonymous users and is actually available
        if (!isModelAvailableForAnonymous(currentModel) || !isModelAvailable(currentModel)) {
            const newModel = getFirstAvailableAnonymousModel();
            
            if (newModel !== currentModel) {
                console.log(`🔄 Switching anonymous user from ${currentModel} to ${newModel}`);
                state.settings.model = newModel;
                
                // Update active chat model too if exists
                const activeChat = state.chats.find(c => c.id === state.activeId);
                if (activeChat) {
                    activeChat.model = newModel;
                }
                
                saveState();
                updateModelSelectorDisplay();
                
                // Show a friendly notification
                showAlert(`Switched to ${MODELS[newModel]?.name || newModel} as your current model was unavailable.`, 'info', 4000);
            }
        }
    }
    
    // New function to update the state of the send button
    function updateSendButtonState() {
        const userInputEmpty = elements.userInput.value.trim() === '';
        if (isStreaming) {
            elements.sendBtn.disabled = false; // Always enabled as a stop button during streaming
        } else {
            // Button is disabled if input is empty OR title is generating.
            // If AI response just finished, and input is empty, the button should still be enabled.
            elements.sendBtn.disabled = isGeneratingTitle; // Only disabled if title is generating
        }
    }
    const FONTS = { 'inter': 'Inter', 'sans-serif': 'Sans Serif', 'work-sans': 'Work Sans', 'yu-gothic': 'Yu Gothic' };
    const FONT_WEIGHTS = { '300': 'Thin', '400': 'Regular', '500': 'Medium', '600': 'Semibold', '700': 'Bold' };

    // Study Mode functions
    function updateStudyModeIndicator() {
        const activeChat = state.chats.find(c => c.id === state.activeId);
        if (activeChat && activeChat.study_mode && elements.studyModeIndicator) {
            elements.studyModeIndicator.classList.remove('hidden');
        } else if (elements.studyModeIndicator) {
            elements.studyModeIndicator.classList.add('hidden');
        }
    }

    // Handle slash commands with improved validation
    function handleSlashCommand(input) {
        const trimmed = input.trim();
        const command = trimmed.toLowerCase();

        if (command === '/study') {
            return { type: 'study', action: 'toggle' };
        } else if (command.startsWith('/study ')) {
            return { type: 'study', action: 'help' };
        }

        return null;
    }
    // Cache version for future-proofing against data structure changes
    const CACHE_VERSION = '1.0';
    
    // Enhanced state management with comprehensive caching and debouncing
    const saveState = () => {
        localStorage.setItem('fronixState', JSON.stringify(state));
        localStorage.setItem('lastActiveChatId', state.activeId); // Persist active chat ID

        // Cache top 10 chats with recent messages for instant loading
        const topChats = state.chats.slice(0, 10).map(chat => ({
            ...chat,
            // Cache last 20 messages for instant chat display
            messages: chat.messages ? chat.messages.slice(-20) : []
        }));

        const cacheData = {
            version: CACHE_VERSION,
            chats: topChats,
            activeId: state.activeId,
            timestamp: Date.now(),
            userEmail: state.currentUser?.email || null,
            currentUser: state.currentUser ? {
                id: state.currentUser.id,
                email: state.currentUser.email,
                username: state.currentUser.username,
                plan: state.currentUser.plan
            } : null
        };

        localStorage.setItem('cachedChats', JSON.stringify(cacheData));
        console.log('[saveState] Cached', topChats.length, 'chats with recent messages');
    };

    // Debounced version of saveState for better performance
    let saveStateTimeout;
    const debouncedSaveState = () => {
        clearTimeout(saveStateTimeout);
        saveStateTimeout = setTimeout(() => {
            saveState();
        }, 500); // 500ms debounce delay
    };

    // Critical state changes should save immediately
    const immediateSaveState = () => {
        clearTimeout(saveStateTimeout);
        saveState();
    };
    
    // Load cached chats for instant UI with version checking
    const loadCachedChats = () => {
        try {
            const cached = localStorage.getItem('cachedChats');
            if (!cached) return false;
            
            const cachedData = JSON.parse(cached);
            
            // Version check - clear cache if version mismatch
            if (cachedData.version !== CACHE_VERSION) {
                console.log('[loadCachedChats] Cache version mismatch, clearing cache');
                clearCachedChats();
                return false;
            }
            
            const isRecent = (Date.now() - cachedData.timestamp) < (24 * 60 * 60 * 1000); // 24 hours
            const currentUserEmail = state.currentUser?.email || localStorage.getItem('authToken') ? 'authenticated' : null;
            
            // Check if cache is recent and for the same user
            if (isRecent && cachedData.chats && cachedData.chats.length > 0) {
                // Restore cached data
                state.chats = cachedData.chats;
                state.activeId = cachedData.activeId;
                
                // Restore user data if available
                if (cachedData.currentUser && !state.currentUser) {
                    state.currentUser = cachedData.currentUser;
                }
                
                const messageCount = cachedData.chats.reduce((total, chat) => total + (chat.messages?.length || 0), 0);
                console.log('[loadCachedChats] Loaded', cachedData.chats.length, 'cached chats with', messageCount, 'messages instantly');
                
                renderSidebar();
                renderChat();
                return true;
            }
        } catch (error) {
            console.warn('[loadCachedChats] Error loading cached chats:', error);
            clearCachedChats(); // Clear corrupted cache
        }
        return false;
    };
    
    // Clear cached chats (called on logout or user change)
    const clearCachedChats = () => {
        localStorage.removeItem('cachedChats');
        console.log('[clearCachedChats] Cached chats cleared');
    };
    // Initialize default chat for new users
    const initializeDefaultChat = () => {
        if (state.chats.length === 0 && !localStorage.getItem('authToken')) {
            const defaultChat = createChat('New Chat');
            state.chats = [defaultChat];
            state.activeId = defaultChat.id;
            renderSidebar();
            renderChat();
            immediateSaveState(); // Critical state change - save immediately
            console.log('[initializeDefaultChat] Created default chat for new user');
        }
    };
    
    const loadState = () => {
        const d = localStorage.getItem('fronixState');
        if (d) {
            const p = JSON.parse(d);
            state.settings = { ...state.settings, ...p.settings };
            if (p.settings.apiToken) elements.settingsModal.apiTokenInput.value = p.settings.apiToken;
        }
        const lastActiveChatId = localStorage.getItem('lastActiveChatId'); // Load last active chat ID
        if (lastActiveChatId) {
            state.activeId = lastActiveChatId;
        }
        if (localStorage.getItem('authToken')) {
            loadDataFromServer();
        } else {
            // Initialize default chat for non-authenticated users
            initializeDefaultChat();
        }
    };

    marked.setOptions({
        highlight: function(code, lang) {
            const language = hljs.getLanguage(lang) ? lang : 'plaintext';
            return hljs.highlight(code, { language }).value;
        },
        langPrefix: 'hljs language-'
    });

    const KATEX_DELIMITERS = [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false },
        { left: '\\[', right: '\\]', display: true }
    ];

    function renderContent(text) { if (!text) return ''; let html = marked.parse(text, { breaks: true, gfm: true }); return html; }
    function renderStreamingContent(text) { if (!text) return ''; let html = marked.parseInline(text, { breaks: true, gfm: true }); return html; }

    // Global Error Boundary System
    class ErrorBoundary {
        constructor() {
            this.errors = [];
            this.maxErrors = 10;
            this.errorTimeout = 5000; // 5 seconds
        }

        // Capture and handle JavaScript errors
        captureError(error, errorInfo = {}) {
            const errorData = {
                message: error.message || error.toString(),
                stack: error.stack,
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                url: window.location.href,
                userId: state.currentUser?.id || 'anonymous',
                ...errorInfo
            };

            this.errors.push(errorData);

            // Keep only recent errors
            if (this.errors.length > this.maxErrors) {
                this.errors.shift();
            }

            console.error('[ErrorBoundary] Captured error:', errorData);

            // Show user-friendly error message
            this.showErrorToUser(errorData);

            // Report to analytics (if available)
            this.reportError(errorData);

            return errorData;
        }

        // Show error to user in a non-intrusive way
        showErrorToUser(errorData) {
            // Don't show error for minor issues
            if (errorData.message.includes('AbortError') ||
                errorData.message.includes('NetworkError') && errorData.message.includes('fetch')) {
                return;
            }

            // Show alert for significant errors
            const isNetworkError = errorData.message.includes('Failed to fetch') ||
                                 errorData.message.includes('NetworkError');

            if (isNetworkError) {
                showAlert('Connection error. Please check your internet connection and try again.', 'warning');
            } else if (!errorData.message.includes('Script error')) {
                // Only show errors that aren't generic script errors
                showAlert('An unexpected error occurred. Please refresh the page if problems persist.', 'error');
            }
        }

        // Report error to monitoring service
        reportError(errorData) {
            // In a real application, send to monitoring service like Sentry
            // For now, just log to console
            console.error('[ErrorReporting] Error report:', errorData);
        }

        // Get recent errors for debugging
        getRecentErrors() {
            return this.errors.slice(-5);
        }

        // Clear old errors
        clearErrors() {
            this.errors = [];
        }
    }

    // Create global error boundary instance
    const errorBoundary = new ErrorBoundary();

    // Global error handler
    window.addEventListener('error', (event) => {
        errorBoundary.captureError(event.error, {
            filename: event.filename,
            lineno: event.lineno,
            colno: event.colno,
            type: 'javascript'
        });
    });

    // Unhandled promise rejection handler
    window.addEventListener('unhandledrejection', (event) => {
        errorBoundary.captureError(event.reason, {
            type: 'promise',
            promise: event.promise
        });
    });

    // Enhanced error handling for fetch requests
    const safeFetch = async (url, options = {}) => {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            return response;
        } catch (error) {
            errorBoundary.captureError(error, {
                type: 'fetch',
                url: url,
                options: options
            });
            throw error;
        }
    };

    // Enhanced error handling for async functions
    const safeAsync = (fn, errorContext = {}) => {
        return async (...args) => {
            try {
                return await fn(...args);
            } catch (error) {
                errorBoundary.captureError(error, errorContext);
                throw error;
            }
        };
    };

    // Mobile detection
    const isMobile = () => window.innerWidth < 768 || ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

    const createChat = (title = 'New Chat') => ({ id: Date.now().toString(), title, messages: [], model: state.settings.model });
    function renderSidebar() {
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        elements.chatList.innerHTML = '';
        state.chats.forEach(chat => {
            const isActive = chat.id === state.activeId;
            let li = document.createElement('li');
            li.className = `group w-full flex items-center justify-between px-4 py-2 rounded-lg cursor-pointer transition-colors relative ${isActive ? 'bg-light-border-active dark:bg-dark-border-active' : 'hover:bg-light-border-hover dark:hover:bg-dark-border-hover'}`;
            
            let actionsHtml;
            if (isTouchDevice) {
                actionsHtml = `<button class="chat-actions-btn p-1 text-light-text-subtle hover:text-light-text dark:hover:text-dark-text rounded"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle></svg></button>`;
            } else {
                actionsHtml = `<div class="sidebar-item-actions flex-shrink-0 flex items-center gap-1">
                    <button class="rename-btn p-1 text-light-text-subtle hover:text-light-text dark:hover:text-dark-text rounded"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg></button>
                    <button class="delete-btn p-1 text-light-text-subtle hover:text-red-500 rounded"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg></button>
                </div>`;
            }

            li.innerHTML = `<span class="truncate text-sm font-medium">${chat.title}</span>${actionsHtml}`;
            
            li.addEventListener('click', () => {
                setActive(chat.id);
                if (window.innerWidth < 768) {
                    toggleSidebar();
                }
            });

            const renameBtn = li.querySelector('.rename-btn');
            if (renameBtn) {
                renameBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openRenameModal(chat.id);
                });
            }

            const deleteBtn = li.querySelector('.delete-btn');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openDeleteModal(chat.id);
                });
            }

            const actionsBtn = li.querySelector('.chat-actions-btn');
            if (actionsBtn) {
                actionsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openChatActionsDropdown(chat.id, e.currentTarget);
                });
            }
            elements.chatList.appendChild(li);
        });
    }

    function setActive(id) {
        console.log(`[setActive] Attempting to set active chat to ID: ${id}`);
        if (state.editingMessage) {
            console.log('[setActive] Exiting edit mode before changing chat.');
            exitEditMode();
        }
        state.activeId = id;
        const chat = state.chats.find(c => c.id === id);
        if (chat) {
            state.settings.model = chat.model || 'gpt-4.1';
            console.log(`[setActive] Chat found. Setting model to: ${state.settings.model}`);
        } else {
            state.activeId = null;
            console.log(`[setActive] Chat with ID ${id} not found. Setting activeId to null.`);
        }
        updateModelSelectorDisplay();
        updateStudyModeIndicator(); // Update study mode indicator when chat changes
        renderModelDropdown();
        console.log(`[setActive] Calling renderSidebar and renderChat for chat ID: ${state.activeId}`);
        renderSidebar();
        renderChat(); // This will now use the messages already loaded in state.chats
        debouncedSaveState(); // Use debounced save for non-critical chat changes
        console.log(`[setActive] Active chat set to: ${state.activeId}. State saved.`);
    }
    
// Place this function where your current addMessage is.
function addMessage(role, content, customId = null) {
    const chat = state.chats.find(c => c.id === state.activeId);
    if (!chat) return;
    
    // Initialize messages array if it doesn't exist
    if (!chat.messages) {
        chat.messages = [];
    }
    
    const message = { role, content };
    if (customId) {
        message.id = customId; // Add the custom ID if provided
    }
    chat.messages.push(message);
    console.log('[addMessage] Message added. Chat messages (after push):', JSON.parse(JSON.stringify(chat.messages))); // Deep copy for logging
    renderChat(); // RenderChat will now correctly use the ID
    debouncedSaveState(); // Use debounced save for message additions
    console.log('[addMessage] State saved after adding message. Current chat messages:', JSON.parse(JSON.stringify(chat.messages))); // Deep copy for logging
};

// Virtual scrolling state for DOM virtualization
let virtualScrollState = {
    visibleStart: 0,
    visibleEnd: 50,
    itemHeight: 120, // Estimated average message height
    bufferSize: 10, // Number of extra items to render above/below visible area
    totalItems: 0,
    scrollTop: 0,
    containerHeight: 0
};

// Function to estimate message height based on content
function estimateMessageHeight(msg, isUser) {
    const baseHeight = isUser ? 80 : 100;
    let contentHeight = 20; // Base content height

    if (typeof msg.content === 'string') {
        const lines = Math.ceil(msg.content.length / 80); // Rough estimate: 80 chars per line
        contentHeight = Math.max(20, lines * 18);
    } else if (Array.isArray(msg.content)) {
        contentHeight = msg.content.length * 60; // Array items take more space
    } else if (msg.content && typeof msg.content === 'object') {
        contentHeight = 80; // Object content
    }

    return baseHeight + contentHeight + 40; // Add padding and actions
}

// Update virtual scroll state based on scroll position
function updateVirtualScrollState() {
    const chat = state.chats.find(c => c.id === state.activeId);
    if (!chat || !chat.messages) return;

    const container = elements.chatBox.parentElement;
    virtualScrollState.containerHeight = container.clientHeight;
    virtualScrollState.scrollTop = container.scrollTop;
    virtualScrollState.totalItems = chat.messages.length;

    // Calculate visible range
    const start = Math.floor(virtualScrollState.scrollTop / virtualScrollState.itemHeight) - virtualScrollState.bufferSize;
    const end = Math.ceil((virtualScrollState.scrollTop + virtualScrollState.containerHeight) / virtualScrollState.itemHeight) + virtualScrollState.bufferSize;

    virtualScrollState.visibleStart = Math.max(0, start);
    virtualScrollState.visibleEnd = Math.min(virtualScrollState.totalItems, end);
}

// Render only visible messages with virtual scrolling
function renderChatVirtualized() {
    const chat = state.chats.find(c => c.id === state.activeId);
    if (!chat) {
        elements.chatBox.innerHTML = `<div class="text-center text-light-text-subtle dark:text-dark-text-subtle py-8"><h2 class="text-3xl font-bold mb-2">Fronix</h2><p>Start a new message to begin.</p></div>`;
        return;
    }

    if (!chat.messages || chat.messages.length === 0) {
        elements.chatBox.innerHTML = `<div class="text-center text-light-text-subtle dark:text-dark-text-subtle py-8"><h2 class="text-3xl font-bold mb-2">Fronix</h2><p>Start a new message to begin.</p></div>`;
        return;
    }

    updateVirtualScrollState();

    // Calculate total height for proper scrolling
    let totalHeight = 0;
    chat.messages.forEach((msg, index) => {
        const isUser = msg.role === 'user';
        const height = estimateMessageHeight(msg, isUser);
        if (index < virtualScrollState.visibleStart) {
            totalHeight += height;
        }
    });

    // Clear existing content
    elements.chatBox.innerHTML = '';

    // Render only visible messages
    const visibleMessages = chat.messages.slice(virtualScrollState.visibleStart, virtualScrollState.visibleEnd);

    visibleMessages.forEach((msg, index) => {
        const globalIndex = virtualScrollState.visibleStart + index;
        const wrapper = document.createElement('div');
        wrapper.style.position = 'absolute';
        wrapper.style.top = totalHeight + 'px';
        wrapper.style.width = '100%';

        const msgDiv = document.createElement('div');
        if (msg.id) {
            msgDiv.id = msg.id;
        }

        const isUser = msg.role === 'user';
        const messageHeight = estimateMessageHeight(msg, isUser);

        if (isUser) {
            msgDiv.className = 'ml-auto w-fit max-w-[90%]';

            // Parse content if it's a JSON string from database
            let content = msg.content;
            if (typeof content === 'string' && (content.startsWith('[') || content.startsWith('{'))) {
                try {
                    content = JSON.parse(content);
                } catch (e) {
                    content = msg.content;
                }
            }

            if (Array.isArray(content)) {
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'p-4 rounded-2xl bg-light-user-bubble dark:bg-dark-user-bubble flex flex-col gap-3';
                content.forEach(part => {
                    if (part.type === 'text' && part.text) {
                        const p = document.createElement('p');
                        p.className = 'whitespace-pre-wrap';
                        p.textContent = part.text;
                        contentWrapper.appendChild(p);
                    } else if (part.type === 'image_url') {
                        const img = document.createElement('img');
                        img.src = part.image_url.url;
                        img.className = 'w-48 h-auto rounded-lg cursor-pointer';
                        img.onclick = () => window.open(part.image_url.url, '_blank');
                        contentWrapper.appendChild(img);
                    }
                });
                msgDiv.appendChild(contentWrapper);
            } else {
                msgDiv.classList.add('p-4', 'rounded-2xl', 'bg-light-user-bubble', 'dark:bg-dark-user-bubble');
                const p = document.createElement('p');
                p.className = 'whitespace-pre-wrap';
                p.textContent = content;
                msgDiv.appendChild(p);
            }
        } else {
            msgDiv.className = 'prose prose-sm md:prose-base max-w-none text-light-text dark:text-dark-text';
            let assistantContent = msg.content;
            if (typeof assistantContent === 'string') {
                const trimmed = assistantContent.trim();
                if (trimmed.startsWith('{') || trimmed.startsWith('[')) {
                    try {
                        assistantContent = JSON.parse(trimmed);
                    } catch (error) {
                        // leave as string if parsing fails
                    }
                }
            }

            if (assistantContent === '...') {
                msgDiv.innerHTML = `<div class="flex items-center space-x-1.5">${Array(3).fill().map(() => `<div class="loader-dot w-2 h-2 bg-gray-400 rounded-full"></div>`).join('')}</div>`;
            } else if (Array.isArray(assistantContent)) {
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'flex flex-col gap-3';
                assistantContent.forEach(part => {
                    if (part.type === 'text' && part.text) {
                        const p = document.createElement('p');
                        p.innerHTML = renderContent(part.text);
                        contentWrapper.appendChild(p);
                    } else if (part.type === 'image_url' && part.image_url?.url) {
                        const img = document.createElement('img');
                        img.src = part.image_url.url;
                        img.className = 'w-full max-w-sm h-auto rounded-lg cursor-pointer';
                        img.onclick = () => window.open(part.image_url.url, '_blank');
                        contentWrapper.appendChild(img);
                    }
                });
                msgDiv.appendChild(contentWrapper);
            } else if (typeof assistantContent === 'object' && assistantContent !== null) {
                if (assistantContent.type === 'html' && assistantContent.html) {
                    msgDiv.innerHTML = assistantContent.html;
                } else if (assistantContent.type === 'text' && assistantContent.text) {
                    msgDiv.innerHTML = renderContent(assistantContent.text);
                    renderMathInElement(msgDiv, {
                        delimiters: KATEX_DELIMITERS
                    });
                } else {
                    msgDiv.innerHTML = renderContent(JSON.stringify(assistantContent));
                    renderMathInElement(msgDiv, {
                        delimiters: KATEX_DELIMITERS
                    });
                }
            } else {
                msgDiv.innerHTML = renderContent(assistantContent || '');
                renderMathInElement(msgDiv, {
                    delimiters: KATEX_DELIMITERS
                });
            }
        }

        const actionsDiv = document.createElement('div');
        actionsDiv.className = `flex gap-2 mt-2 items-center text-light-text-subtle dark:text-dark-text-subtle ${isUser ? 'justify-end' : 'justify-start'}`;
        const copyBtn = document.createElement('button');
        copyBtn.className = 'p-1 hover:text-light-text dark:hover:text-dark-text rounded-md transition-colors copy-btn';
        copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
        copyBtn.dataset.messageContent = JSON.stringify(msg.content);
        actionsDiv.appendChild(copyBtn);

        if (isUser) {
            const editBtn = document.createElement('button');
            editBtn.className = 'p-1 hover:text-light-text dark:hover:text-dark-text rounded-md transition-colors edit-btn';
            editBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>`;
            editBtn.dataset.chatId = chat.id;
            editBtn.dataset.messageIndex = globalIndex;
            actionsDiv.appendChild(editBtn);
        }

        wrapper.appendChild(msgDiv);
        wrapper.appendChild(actionsDiv);
        elements.chatBox.appendChild(wrapper);

        totalHeight += messageHeight;
    });

    // Set container height for proper scrolling
    elements.chatBox.style.height = totalHeight + 'px';
    bindGeneratedImageEditButtons();
}

// Message processing optimization with diffing
let messageCache = new Map();
let lastRenderedMessages = new Map();

// Create message diffing function to identify changes
function createMessageDiff(currentMessages, newMessages) {
    const diff = {
        added: [],
        removed: [],
        changed: [],
        unchanged: []
    };

    // Create maps for efficient lookup
    const currentMap = new Map();
    const newMap = new Map();

    currentMessages.forEach((msg, index) => {
        const key = `${msg.role}-${JSON.stringify(msg.content)}`;
        currentMap.set(key, { msg, index });
    });

    newMessages.forEach((msg, index) => {
        const key = `${msg.role}-${JSON.stringify(msg.content)}`;
        newMap.set(key, { msg, index });
    });

    // Find added, removed, and changed messages
    for (const [key, current] of currentMap) {
        if (newMap.has(key)) {
            diff.unchanged.push(current);
        } else {
            diff.removed.push(current);
        }
    }

    for (const [key, newMsg] of newMap) {
        if (!currentMap.has(key)) {
            diff.added.push(newMsg);
        }
    }

    return diff;
}

// Cache parsed message content to avoid re-parsing
function getCachedMessageContent(msg) {
    const cacheKey = `${msg.role}-${JSON.stringify(msg.content)}`;

    if (messageCache.has(cacheKey)) {
        return messageCache.get(cacheKey);
    }

    let content = msg.content;
    if (typeof content === 'string' && (content.startsWith('[') || content.startsWith('{'))) {
        try {
            content = JSON.parse(content);
        } catch (e) {
            content = msg.content;
        }
    }

    const cachedContent = { original: msg.content, parsed: content };
    messageCache.set(cacheKey, cachedContent);

    // Limit cache size
    if (messageCache.size > 500) {
        const firstKey = messageCache.keys().next().value;
        messageCache.delete(firstKey);
    }

    return cachedContent;
}

// Optimized message rendering with selective updates
function renderMessageOptimized(chat, msg, index, isUser, container) {
    const cachedContent = getCachedMessageContent(msg);
    const wrapper = document.createElement('div');
    const msgDiv = document.createElement('div');

    if (msg.id) {
        msgDiv.id = msg.id;
    }

    if (isUser) {
        msgDiv.className = 'ml-auto w-fit max-w-[90%]';

        if (Array.isArray(cachedContent.parsed)) {
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'p-4 rounded-2xl bg-light-user-bubble dark:bg-dark-user-bubble flex flex-col gap-3';
            cachedContent.parsed.forEach(part => {
                if (part.type === 'text' && part.text) {
                    const p = document.createElement('p');
                    p.className = 'whitespace-pre-wrap';
                    p.textContent = part.text;
                    contentWrapper.appendChild(p);
                } else if (part.type === 'image_url') {
                    const img = document.createElement('img');
                    img.src = part.image_url.url;
                    img.className = 'w-48 h-auto rounded-lg cursor-pointer';
                    img.onclick = () => window.open(part.image_url.url, '_blank');
                    contentWrapper.appendChild(img);
                }
            });
            msgDiv.appendChild(contentWrapper);
        } else {
            msgDiv.classList.add('p-4', 'rounded-2xl', 'bg-light-user-bubble', 'dark:bg-dark-user-bubble');
            const p = document.createElement('p');
            p.className = 'whitespace-pre-wrap';
            p.textContent = cachedContent.parsed;
            msgDiv.appendChild(p);
        }
    } else {
        msgDiv.className = 'prose prose-sm md:prose-base max-w-none text-light-text dark:text-dark-text';

        if (cachedContent.parsed === '...') {
            msgDiv.innerHTML = `<div class="flex items-center space-x-1.5">${Array(3).fill().map(() => `<div class="loader-dot w-2 h-2 bg-gray-400 rounded-full"></div>`).join('')}</div>`;
        } else if (Array.isArray(cachedContent.parsed)) {
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'flex flex-col gap-3';
            cachedContent.parsed.forEach(part => {
                if (part.type === 'text' && part.text) {
                    const p = document.createElement('p');
                    p.innerHTML = renderContent(part.text);
                    contentWrapper.appendChild(p);
                } else if (part.type === 'image_url' && part.image_url?.url) {
                    const img = document.createElement('img');
                    img.src = part.image_url.url;
                    img.className = 'w-full max-w-sm h-auto rounded-lg cursor-pointer';
                    img.onclick = () => window.open(part.image_url.url, '_blank');
                    contentWrapper.appendChild(img);
                }
            });
            msgDiv.appendChild(contentWrapper);
        } else if (typeof cachedContent.parsed === 'object' && cachedContent.parsed !== null) {
            if (cachedContent.parsed.type === 'html' && cachedContent.parsed.html) {
                msgDiv.innerHTML = cachedContent.parsed.html;
            } else if (cachedContent.parsed.type === 'text' && cachedContent.parsed.text) {
                msgDiv.innerHTML = renderContent(cachedContent.parsed.text);
                renderMathInElement(msgDiv, {
                    delimiters: [{ left: "[", right: "]", display: true }, { left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }]
                });
            } else {
                msgDiv.innerHTML = renderContent(JSON.stringify(cachedContent.parsed));
                renderMathInElement(msgDiv, {
                    delimiters: [{ left: "[", right: "]", display: true }, { left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }]
                });
            }
        } else {
            msgDiv.innerHTML = renderContent(cachedContent.parsed || '');
            renderMathInElement(msgDiv, {
                delimiters: [{ left: "[", right: "]", display: true }, { left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }]
            });
        }
    }

    // Add action buttons with event delegation
    const actionsDiv = document.createElement('div');
    actionsDiv.className = `flex gap-2 mt-2 items-center text-light-text-subtle dark:text-dark-text-subtle ${isUser ? 'justify-end' : 'justify-start'}`;
    const copyBtn = document.createElement('button');
    copyBtn.className = 'p-1 hover:text-light-text dark:hover:text-dark-text rounded-md transition-colors copy-btn';
    copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
    copyBtn.dataset.messageContent = JSON.stringify(msg.content);
    actionsDiv.appendChild(copyBtn);

    if (isUser) {
        const editBtn = document.createElement('button');
        editBtn.className = 'p-1 hover:text-light-text dark:hover:text-dark-text rounded-md transition-colors edit-btn';
        editBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>`;
        editBtn.dataset.chatId = chat.id;
        editBtn.dataset.messageIndex = index;
        actionsDiv.appendChild(editBtn);
    }

    wrapper.appendChild(msgDiv);
    wrapper.appendChild(actionsDiv);
    container.appendChild(wrapper);

    return wrapper;
}

// Enhanced scroll handler for virtual scrolling
function handleVirtualScroll() {
    const container = elements.chatBox.parentElement;
    const oldScrollTop = virtualScrollState.scrollTop;

    container.addEventListener('scroll', () => {
        const newScrollTop = container.scrollTop;

        // Only re-render if scroll position changed significantly
        if (Math.abs(newScrollTop - oldScrollTop) > virtualScrollState.itemHeight) {
            renderChatVirtualized();
        }
    });
}

// Image lazy loading and caching system
let imageObserver;
let imageCache = new Map();
let loadingImages = new Set();

// Initialize image lazy loading
function initImageLazyLoading() {
    // Create intersection observer for lazy loading
    imageObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const img = entry.target;
                loadImage(img);
                imageObserver.unobserve(img);
            }
        });
    }, {
        rootMargin: '50px' // Start loading 50px before image comes into view
    });

    // Observe all existing lazy images
    document.querySelectorAll('img[data-src]').forEach(img => {
        imageObserver.observe(img);
    });

    // Set up Service Worker for caching if supported
    if ('serviceWorker' in navigator) {
        registerServiceWorker();
    }
}

// Load image with caching and error handling
function loadImage(img) {
    const src = img.dataset.src || img.src;
    if (!src) return;

    // Check cache first
    if (imageCache.has(src)) {
        img.src = imageCache.get(src);
        img.classList.remove('lazy');
        return;
    }

    // Show loading placeholder
    showImagePlaceholder(img);

    // Create new image for loading
    const newImg = new Image();

    newImg.onload = () => {
        // Cache the loaded image
        imageCache.set(src, src);

        // Update the original image
        img.src = src;
        img.classList.remove('lazy', 'loading');
        img.classList.add('loaded');
        loadingImages.delete(img);

        // Clean cache if it gets too large
        if (imageCache.size > 100) {
            const firstKey = imageCache.keys().next().value;
            imageCache.delete(firstKey);
        }
    };

    newImg.onerror = () => {
        console.warn('Failed to load image:', src);
        img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5YTNhZCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIE5vdCBBdmFpbGFibGU8L3RleHQ+PC9zdmc+';
        img.classList.remove('lazy', 'loading');
        img.classList.add('error');
        loadingImages.delete(img);
    };

    loadingImages.add(img);
    newImg.src = src;
}

// Show loading placeholder for image
function showImagePlaceholder(img) {
    const rect = img.getBoundingClientRect();
    const aspectRatio = img.dataset.aspect || '1';

    img.classList.add('loading');
    img.style.background = `linear-gradient(90deg, #f3f4f6 25%, #e5e7eb 50%, #f3f4f6 75%)`;
    img.style.backgroundSize = '200% 100%';
    img.style.animation = 'loading-shimmer 2s infinite';
}

// Register Service Worker for image caching
async function registerServiceWorker() {
    try {
        const registration = await navigator.serviceWorker.register('/sw.js');
        console.log('[ServiceWorker] Registered successfully:', registration.scope);
    } catch (error) {
        console.log('[ServiceWorker] Registration failed:', error);
    }
}

// Add CSS for lazy loading animations
const lazyLoadingCSS = `
    <style>
    img.lazy {
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    img.loaded {
        opacity: 1;
    }

    img.error {
        opacity: 0.7;
        filter: grayscale(100%);
    }

    @keyframes loading-shimmer {
        0% { background-position: -200% 0; }
        100% { background-position: 200% 0; }
    }

    .image-placeholder {
        background: linear-gradient(90deg, #f3f4f6 25%, #e5e7eb 50%, #f3f4f6 75%);
        background-size: 200% 100%;
        animation: loading-shimmer 2s infinite;
    }
    </style>
`;

// Inject CSS
document.head.insertAdjacentHTML('beforeend', lazyLoadingCSS);

// Enhanced image creation with lazy loading
function createLazyImage(src, className = '', alt = '') {
    const img = document.createElement('img');
    img.dataset.src = src;
    img.className = `lazy ${className}`.trim();
    img.alt = alt;
    img.loading = 'lazy'; // Native lazy loading as fallback

    // Add placeholder
    showImagePlaceholder(img);

    return img;
}

// Update existing image rendering to use lazy loading
function updateImageRendering() {
    // Replace existing img elements with lazy loading versions
    document.querySelectorAll('img:not(.lazy)').forEach(img => {
        if (!img.src.startsWith('data:') && !img.src.includes('blob:')) {
            const src = img.src;
            img.dataset.src = src;
            img.src = '';
            img.classList.add('lazy');
            showImagePlaceholder(img);
            imageObserver.observe(img);
        }
    });
}

// Replace the old renderChat with virtualized version
function renderChat() {
    // Use virtualized rendering for better performance with large chat histories
    if (state.chats.find(c => c.id === state.activeId)?.messages?.length > 50) {
        renderChatVirtualized();
    } else {
        // Fall back to regular rendering for small chats
        renderChatRegular();
    }
}

// Keep the original function as fallback
function renderChatRegular() {
    const chat = state.chats.find(c => c.id === state.activeId);
    elements.chatBox.innerHTML = '';

    if (!chat) {
        elements.chatBox.innerHTML = `<div class="text-center text-light-text-subtle dark:text-dark-text-subtle py-8"><h2 class="text-3xl font-bold mb-2">Fronix</h2><p>Start a new message to begin.</p></div>`;
        return;
    }

    if (!chat.messages || chat.messages.length === 0) {
        elements.chatBox.innerHTML = `<div class="text-center text-light-text-subtle dark:text-dark-text-subtle py-8"><h2 class="text-3xl font-bold mb-2">Fronix</h2><p>Start a new message to begin.</p></div>`;
        return;
    }

    chat.messages.forEach((msg, index) => {
        const wrapper = document.createElement('div');
        const msgDiv = document.createElement('div');

        if (msg.id) {
            msgDiv.id = msg.id;
        }

        const isUser = msg.role === 'user';

        if (isUser) {
            msgDiv.className = 'ml-auto w-fit max-w-[90%]';

            let content = msg.content;
            if (typeof content === 'string' && (content.startsWith('[') || content.startsWith('{'))) {
                try {
                    content = JSON.parse(content);
                } catch (e) {
                    content = msg.content;
                }
            }

            if (Array.isArray(content)) {
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'p-4 rounded-2xl bg-light-user-bubble dark:bg-dark-user-bubble flex flex-col gap-3';
                content.forEach(part => {
                    if (part.type === 'text' && part.text) {
                        const p = document.createElement('p');
                        p.className = 'whitespace-pre-wrap';
                        p.textContent = part.text;
                        contentWrapper.appendChild(p);
                    } else if (part.type === 'image_url') {
                        const img = document.createElement('img');
                        img.src = part.image_url.url;
                        img.className = 'w-48 h-auto rounded-lg cursor-pointer';
                        img.onclick = () => window.open(part.image_url.url, '_blank');
                        contentWrapper.appendChild(img);
                    }
                });
                msgDiv.appendChild(contentWrapper);
            } else {
                msgDiv.classList.add('p-4', 'rounded-2xl', 'bg-light-user-bubble', 'dark:bg-dark-user-bubble');
                const p = document.createElement('p');
                p.className = 'whitespace-pre-wrap';
                p.textContent = content;
                msgDiv.appendChild(p);
            }
        } else {
            msgDiv.className = 'prose prose-sm md:prose-base max-w-none text-light-text dark:text-dark-text';
            let assistantContent = msg.content;
            if (typeof assistantContent === 'string') {
                const trimmed = assistantContent.trim();
                if (trimmed.startsWith('{') || trimmed.startsWith('[')) {
                    try {
                        assistantContent = JSON.parse(trimmed);
                    } catch (error) {
                        // leave as string if parsing fails
                    }
                }
            }

            if (assistantContent === '...') {
                msgDiv.innerHTML = `<div class="flex items-center space-x-1.5">${Array(3).fill().map(() => `<div class="loader-dot w-2 h-2 bg-gray-400 rounded-full"></div>`).join('')}</div>`;
            } else if (Array.isArray(assistantContent)) {
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'flex flex-col gap-3';
                assistantContent.forEach(part => {
                    if (part.type === 'text' && part.text) {
                        const p = document.createElement('p');
                        p.innerHTML = renderContent(part.text);
                        contentWrapper.appendChild(p);
                    } else if (part.type === 'image_url' && part.image_url?.url) {
                        const img = document.createElement('img');
                        img.src = part.image_url.url;
                        img.className = 'w-full max-w-sm h-auto rounded-lg cursor-pointer';
                        img.onclick = () => window.open(part.image_url.url, '_blank');
                        contentWrapper.appendChild(img);
                    }
                });
                msgDiv.appendChild(contentWrapper);
            } else if (typeof assistantContent === 'object' && assistantContent !== null) {
                if (assistantContent.type === 'html' && assistantContent.html) {
                    msgDiv.innerHTML = assistantContent.html;
                } else if (assistantContent.type === 'text' && assistantContent.text) {
                    msgDiv.innerHTML = renderContent(assistantContent.text);
                    renderMathInElement(msgDiv, {
                        delimiters: [{ left: "[", right: "]", display: true }, { left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }]
                    });
                } else {
                    msgDiv.innerHTML = renderContent(JSON.stringify(assistantContent));
                    renderMathInElement(msgDiv, {
                        delimiters: [{ left: "[", right: "]", display: true }, { left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }]
                    });
                }
            } else {
                msgDiv.innerHTML = renderContent(assistantContent || '');
                renderMathInElement(msgDiv, {
                    delimiters: [{ left: "[", right: "]", display: true }, { left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }]
                });
            }
        }

        const actionsDiv = document.createElement('div');
        actionsDiv.className = `flex gap-2 mt-2 items-center text-light-text-subtle dark:text-dark-text-subtle ${isUser ? 'justify-end' : 'justify-start'}`;
        const copyBtn = document.createElement('button');
        copyBtn.className = 'p-1 hover:text-light-text dark:hover:text-dark-text rounded-md transition-colors copy-btn';
        copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
        copyBtn.dataset.messageContent = JSON.stringify(msg.content);
        actionsDiv.appendChild(copyBtn);

        if (isUser) {
            const editBtn = document.createElement('button');
            editBtn.className = 'p-1 hover:text-light-text dark:hover:text-dark-text rounded-md transition-colors edit-btn';
            editBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>`;
            editBtn.dataset.chatId = chat.id;
            editBtn.dataset.messageIndex = index;
            actionsDiv.appendChild(editBtn);
        }

        wrapper.appendChild(msgDiv);
        wrapper.appendChild(actionsDiv);
        elements.chatBox.appendChild(wrapper);
    });
    elements.chatBox.parentElement.scrollTop = elements.chatBox.parentElement.scrollHeight;
    bindGeneratedImageEditButtons();
}
// Function to scroll to the bottom of the chat
function scrollToBottom() {
    const chat = state.chats.find(c => c.id === state.activeId);
    if (!chat || !chat.messages) return;

    // For virtual scrolling, calculate total height and scroll to bottom
    if (chat.messages.length > 50) {
        let totalHeight = 0;
        chat.messages.forEach((msg) => {
            const isUser = msg.role === 'user';
            totalHeight += estimateMessageHeight(msg, isUser);
        });
        elements.chatBox.parentElement.scrollTo({
            top: totalHeight,
            behavior: 'smooth'
        });
    } else {
        // Regular scrolling for small chats
        elements.chatBox.parentElement.scrollTo({
            top: elements.chatBox.parentElement.scrollHeight,
            behavior: 'smooth'
        });
    }
}

async function sendMessage() {
    const userInput = elements.userInput.value.trim();
    const activeChat = state.chats.find(c => c.id === state.activeId);
    console.log(`[sendMessage] Start: isStreaming = ${isStreaming}, isGeneratingTitle = ${isGeneratingTitle}`);
    if ((!userInput && !attachedImageData) || !activeChat || isStreaming || isGeneratingTitle) {
        console.log(`[sendMessage] Aborting due to input/chat/streaming/title gen state. isStreaming = ${isStreaming}, isGeneratingTitle = ${isGeneratingTitle}`);
        return;
    }
    
    // Handle message editing
    const wasEditing = !!state.editingMessage; // Store editing state
    let attachmentPreviewUrl = getAttachmentPreviewUrl();
    let attachmentDataUrl = getAttachmentDataUrl();
    if (state.editingMessage) {
        let newContent;

        // Only wait for attachmentDownloadPromise if we don't already have the image data
        // This prevents the 1-second delay when editing messages with existing images
        if (attachmentDownloadPromise && !attachedImageData?.dataUrl) {
            try {
                await attachmentDownloadPromise;
                attachmentDataUrl = getAttachmentDataUrl();
            } catch (error) {
                console.error('Failed to finish preparing attachment before send:', error);
                showAlert('Could not prepare the attached image. Please try again.', 'error', 4000);
                clearAttachedImage();
                return;
            }
        }

        attachmentPreviewUrl = attachmentPreviewUrl || attachmentDataUrl;
        attachmentDataUrl = attachmentDataUrl || attachmentPreviewUrl;

        if (attachedImageData) {
            // If an image is attached, save as multimodal
            newContent = [
                { type: 'text', text: userInput },
                { type: 'image_url', image_url: { url: attachmentDataUrl } }
            ];
        } else {
            // Otherwise, save as plain text
            newContent = userInput;
        }

        // Update the message content
        activeChat.messages[state.editingMessage.messageIndex].content = newContent;
        // Truncate history after this message
        activeChat.messages.length = state.editingMessage.messageIndex + 1;
        
        exitEditMode(); // Reset the UI and state
        saveState();
        
        // Continue to send the edited message to get a new response
        // Don't return here - let the function continue to send the message
    }

    attachmentPreviewUrl = getAttachmentPreviewUrl();
    attachmentDataUrl = getAttachmentDataUrl();

    // Check authentication - handle both logged-in and anonymous users
    const isAnonymous = isAnonymousUser();
    let token = null;
    
    if (!isAnonymous) {
        // Validate token for logged-in users
        token = await validateAndRefreshToken();
        if (!token) {
            showAlert("Your session has expired. Please sign in again.", 'warning');
            setTimeout(() => {
                animateModalOpen(elements.signinModal.container);
            }, 1000);
            return;
        }
    } else {
        // For anonymous users, check if the selected model is allowed and available
        let currentModel = activeChat.model || state.settings.model || 'gpt-4.1';
        
        if (!isModelAvailableForAnonymous(currentModel)) {
            showAlert("This model requires you to sign in. Please log in or select a model available for anonymous use.", 'warning');
            return;
        }
        
        // If the model is not available, switch to the next available one
        if (!isModelAvailable(currentModel)) {
            const availableModel = getFirstAvailableAnonymousModel();
            console.log(`🔄 Current model ${currentModel} unavailable, switching to ${availableModel}`);
            
            // Update the active chat and settings
            activeChat.model = availableModel;
            state.settings.model = availableModel;
            saveState();
            updateModelSelectorDisplay();
            
            showAlert(`Switched to ${MODELS[availableModel]?.name || availableModel} as ${MODELS[currentModel]?.name || currentModel} was unavailable.`, 'info', 4000);
        }
    }

    // Handle image generation models separately
    const currentModelKey = activeChat.model || state.settings.model;
    const modelData = MODELS[currentModelKey];

    if (modelData && modelData.type === 'image') {
        handleImageGeneration(userInput, currentModelKey);
        return; // Stop execution for image models
    }

    // Handle /study command with improved error handling and anonymous user support
    const command = handleSlashCommand(userInput.trim());
    if (command && command.type === 'study') {
        elements.userInput.value = '';
        elements.userInput.style.height = 'auto';

        if (command.action === 'help') {
            addMessage('user', userInput.trim());
            addMessage('assistant', '📚 **Study Mode Help:**\n\n• `/study` - Toggle study mode on/off\n• Study mode provides educational guidance and structured learning\n• Perfect for homework help, concept explanations, and practice exercises\n• Works with both authenticated and anonymous users');
            return;
        }

        // Toggle study mode
        const activeChat = state.chats.find(c => c.id === state.activeId);
        if (!activeChat) {
            showAlert('No active chat found. Please select or create a chat first.', 'warning');
            return;
        }

        const originalStudyMode = activeChat.study_mode || false;
        const newStudyModeStatus = !originalStudyMode;

        // Add user's command to chat history
        addMessage('user', '/study');

        // Optimistically update UI
        activeChat.study_mode = newStudyModeStatus;
        updateStudyModeIndicator();
        debouncedSaveState(); // Use debounced save for study mode changes
        addMessage('assistant', `📚 Study mode ${newStudyModeStatus ? 'enabled' : 'disabled'}. ${newStudyModeStatus ? 'I\'ll help guide your learning!' : 'Switched back to normal mode.'}`);

        // Determine the correct endpoint based on authentication status
        const isAnonymous = isAnonymousUser();
        const endpoint = isAnonymous
            ? `${API_BASE_URL}/api/chat/anonymous/${activeChat.id}/toggle-study-mode`
            : `${API_BASE_URL}/api/chat/${activeChat.id}/toggle-study-mode`;

        const headers = {
            'Content-Type': 'application/json'
        };

        // Only add authorization header for authenticated users
        if (!isAnonymous) {
            const token = await validateAndRefreshToken();
            if (!token) {
                showAlert('Your session has expired. Please sign in again.', 'warning');
                // Revert optimistic update
                activeChat.study_mode = originalStudyMode;
                updateStudyModeIndicator();
                debouncedSaveState(); // Use debounced save for error rollback
                addMessage('assistant', '⚠️ Failed to toggle study mode due to authentication error. Please sign in and try again.');
                return;
            }
            headers['Authorization'] = `Bearer ${token}`;
        }

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: headers
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || `HTTP ${response.status}: ${response.statusText}`);
            }

            // Success - backend confirmed the change
            console.log(`Study mode toggled successfully to: ${data.study_mode}`);

            // If anonymous, the backend doesn't actually store the state, so it's managed locally
            if (isAnonymous) {
                console.log('Anonymous study mode - state managed locally');
            }

        } catch (error) {
            console.error("Error toggling study mode:", error);

            // Show user-friendly error message
            let errorMsg = 'Failed to toggle study mode.';
            if (error.message.includes('404')) {
                errorMsg = 'Chat not found. The study mode state has been updated locally.';
            } else if (error.message.includes('403')) {
                errorMsg = 'You do not have permission to modify this chat.';
            } else if (error.message.includes('fetch')) {
                errorMsg = 'Network error. Study mode has been updated locally.';
            }

            showAlert(errorMsg, 'warning');

            // Revert optimistic UI update on error
            activeChat.study_mode = originalStudyMode;
            updateStudyModeIndicator();
            debouncedSaveState(); // Use debounced save for error rollback

            // Add error message to chat
            addMessage('assistant', `⚠️ ${errorMsg} Reverting to ${originalStudyMode ? 'enabled' : 'disabled'}.`);
        } finally {
            // Reset UI elements
            elements.sendIcon.classList.remove('hidden');
            elements.stopIcon.classList.add('hidden');
            elements.sendBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
            elements.sendBtn.classList.add('bg-accent', 'hover:bg-accent-hover');
            updateSendButtonState();
            elements.userInput.disabled = false;
            isStreaming = false;
        }
        return; // Exit sendMessage function after handling /study command
    } // Call updateSendButtonState at the start of sendMessage (after /study handling)
    setStreamingUIState(true);

    const requestAttachment = attachedImageData ? { previewUrl: attachmentPreviewUrl, dataUrl: attachmentDataUrl } : null;
    const userMessagePayload = requestAttachment
        ? [
            { type: 'text', text: userInput },
            {
                type: 'image_url',
                image_url: {
                    url: requestAttachment.previewUrl
                }
            }
        ]
        : userInput;

    // Only add user message if we're not editing (editing already updated the existing message)
    if (!wasEditing) {
        const userMessageObj = { role: 'user', content: userMessagePayload };
        activeChat.messages.push(userMessageObj);
    }

    // Always add assistant placeholder for the response
    const assistantMessageObj = { role: 'assistant', content: '...', id: 'assistant-msg-' + Date.now() }; // Temporary ID for placeholder
    activeChat.messages.push(assistantMessageObj);
    console.log('[sendMessage] Messages optimistically added. activeChat.messages (after push):', JSON.parse(JSON.stringify(activeChat.messages))); // Deep copy for logging
    renderChat(); // Render immediately with new messages
    scrollToBottom();

    // Clear UI immediately for snappier UX
    elements.userInput.value = '';
    elements.userInput.style.height = 'auto';

    // Always clear attachment immediately after sending to prevent it from staying
    if (attachedImageData) {
        clearAttachedImage();
    }

    const assistantMsgDiv = document.getElementById(assistantMessageObj.id); // Get the placeholder div

    const outboundMessages = prepareMessagesForAI(activeChat, {
        excludeMessageId: assistantMessageObj.id,
        includeSystemPrompt: true
    });

    const requestHeaders = {
        'Content-Type': 'application/json'
    };

    if (!isAnonymous && token) {
        requestHeaders['Authorization'] = `Bearer ${token}`;
    }

    const requestUrl = isAnonymous
        ? `${API_BASE_URL}/api/ai/chat-public`
        : `${API_BASE_URL}/api/ai/chat`;

    const requestBodyBase = isAnonymous
        ? {
            model: activeChat.model || state.settings.model || 'gpt-4.1',
            messages: outboundMessages
        }
        : {
            model: activeChat.model || state.settings.model || 'gpt-4.1',
            messages: outboundMessages,
            chatId: activeChat.id,
            proModelsEnabled: state.settings.proModelsEnabled,
            betaModelsEnabled: state.settings.betaModelsEnabled
        };

    let attempt = 0;
    let lastError = null;
    const maxAttempts = STREAM_ERROR_MAX_RETRIES + 1;

    while (attempt < maxAttempts) {
        currentController = new AbortController();
        let fullResponse = "";

        try {
            isStreaming = true;
            setStreamingUIState(true);

            const requestBody = { ...requestBodyBase };

            const response = await fetch(requestUrl, {
                method: 'POST',
                headers: requestHeaders,
                body: JSON.stringify(requestBody),
                signal: currentController.signal
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (!line.startsWith('data: ')) continue;

                    const data = line.slice(6).trim();
                    if (data === '[DONE]') {
                        const assistantIndex = activeChat.messages.length - 1;
                        const userIndex = assistantIndex - 1;
                        activeChat.messages[assistantIndex].content = fullResponse;
                        immediateSaveState();

                        const userMessageForSave = activeChat.messages[userIndex];
                        const assistantMessageForSave = activeChat.messages[assistantIndex];
                        if (!isAnonymous && userMessageForSave && assistantMessageForSave) {
                            await saveMessagesToServer(activeChat.id, userMessageForSave, assistantMessageForSave, token);
                        }

                        console.log(`[sendMessage] Stream completed on attempt ${attempt + 1}`);
                        return;
                    }

                    try {
                        const parsedData = JSON.parse(data);
                        if (parsedData.error) {
                            throw new Error(parsedData.error.message || 'Unknown streaming error');
                        }

                        if (parsedData.choices && parsedData.choices[0]) {
                            const { delta, finish_reason } = parsedData.choices[0];

                            if (delta && delta.content) {
                                fullResponse += delta.content;
                                assistantMsgDiv.innerHTML = renderContent(fullResponse);
                                scrollToBottom();
                            }

                            if (finish_reason === 'function_call' && delta && delta.function_call) {
                                console.log('🔧 Function call received:', delta.function_call.name);
                                handleFunctionCall(delta.function_call, assistantMsgDiv);
                            }
                        }
                    } catch (e) {
                        continue;
                    }
                }
            }

            console.warn('[sendMessage] Stream ended unexpectedly without [DONE] marker.');
            break;

        } catch (error) {
            lastError = error;
            const message = error?.message || '';
            const shouldRetry = isRetryableStreamError(message) && attempt < STREAM_ERROR_MAX_RETRIES;

            if (shouldRetry) {
                console.warn(`[sendMessage] Stream attempt ${attempt + 1} failed: ${message}. Retrying...`);
                const assistantIndex = activeChat.messages.length - 1;
                if (activeChat.messages[assistantIndex]) {
                    activeChat.messages[assistantIndex].content = '...';
                }
                if (assistantMsgDiv) {
                    assistantMsgDiv.innerHTML = renderContent('...');
                }
                await sleep(STREAM_ERROR_RETRY_DELAY_MS);
                attempt++;
                continue;
            }

            console.error('[sendMessage] Stream failed without retry:', error);
            const lastMessageIndex = activeChat.messages.length - 1;
            if (activeChat.messages[lastMessageIndex] && activeChat.messages[lastMessageIndex].role === 'assistant') {
                activeChat.messages[lastMessageIndex].content = `An error occurred: ${message}`;
                renderChat();
            }
            break;

        } finally {
            isStreaming = false;
            setStreamingUIState(false);
            currentController = null;
        }
    }

    if (lastError) {
        showAlert('Streaming failed. Please try again.', 'error', 5000);
    }
    console.log('[sendMessage] End: Stream finished or aborted.');
}

// Handle function call responses from AI
async function handleFunctionCall(functionCall, assistantMsgDiv) {
    try {
        // Show function call in progress
        assistantMsgDiv.innerHTML = `
            <div class="function-call-container bg-light-border dark:bg-dark-border rounded-lg p-4 mb-2">
                <div class="flex items-center gap-2 mb-2">
                    <div class="w-4 h-4 border-2 border-accent border-t-transparent rounded-full animate-spin"></div>
                    <span class="text-sm font-medium text-light-text dark:text-dark-text">Executing ${functionCall.name}...</span>
                </div>
                <div class="text-xs text-light-text-subtle dark:text-dark-text-subtle">
                    ${functionCall.name === 'generate_image' ? '🎨 Generating image...' :
                      functionCall.name === 'edit_image' ? '✏️ Editing image...' :
                      functionCall.name === 'web_search' ? '🔍 Searching web...' : '⚙️ Processing...'}
                </div>
            </div>
        `;

        // The function execution is handled by the backend
        // We just need to wait for the function result to be streamed back

    } catch (error) {
        console.error('Error handling function call:', error);
        assistantMsgDiv.innerHTML = `
            <div class="function-call-container bg-red-50 dark:bg-red-900/20 rounded-lg p-4 mb-2">
                <div class="text-sm font-medium text-red-600 dark:text-red-400">Function Error</div>
                <div class="text-xs text-red-500 dark:text-red-300">${error.message}</div>
            </div>
        `;
    }
}

// Enhanced message rendering for function results
function renderFunctionResult(functionName, result) {
    const container = document.createElement('div');
    container.className = 'function-result-container bg-light-border dark:bg-dark-border rounded-lg p-4 mb-2';

    switch (functionName) {
        case 'generate_image':
            container.innerHTML = `
                <div class="flex items-center gap-2 mb-3">
                    <span class="text-lg">🎨</span>
                    <span class="text-sm font-medium text-light-text dark:text-dark-text">Image Generated</span>
                </div>
                <div class="relative" style="max-width: 400px; max-height: 600px; overflow: hidden; border-radius: 0.5rem;">
                    <img src="${result.image_url}" alt="${result.prompt_used}" style="width: 100%; height: auto; display: block; border-radius: 0.5rem;"/>
                    <div class="absolute bottom-2 left-2 bg-black/50 text-white text-xs px-2 py-1 rounded">
                        ${result.model_used} • ${result.quality}
                    </div>
                </div>
                <div class="text-xs text-light-text-subtle dark:text-dark-text-subtle mt-2">
                    Model: ${result.model_used} | Quality: ${result.quality}
                </div>
            `;
            break;

        case 'edit_image':
            container.innerHTML = `
                <div class="flex items-center gap-2 mb-3">
                    <span class="text-lg">✏️</span>
                    <span class="text-sm font-medium text-light-text dark:text-dark-text">Image Edited</span>
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <div class="text-xs text-light-text-subtle dark:text-dark-text-subtle mb-1">Original</div>
                        <img src="${result.original_image_url}" alt="Original" class="w-full h-32 object-cover rounded border cursor-pointer" onclick="window.open('${result.original_image_url}', '_blank')"/>
                    </div>
                    <div>
                        <div class="text-xs text-light-text-subtle dark:text-dark-text-subtle mb-1">Edited</div>
                        <img src="${result.edited_image_url}" alt="Edited" class="w-full h-32 object-cover rounded border cursor-pointer" onclick="window.open('${result.edited_image_url}', '_blank')"/>
                    </div>
                </div>
                <div class="text-xs text-light-text-subtle dark:text-dark-text-subtle mt-2">
                    Model: ${result.model_used}
                </div>
            `;
            break;

        case 'web_search':
            container.innerHTML = `
                <div class="flex items-center gap-2 mb-3">
                    <span class="text-lg">🔍</span>
                    <span class="text-sm font-medium text-light-text dark:text-dark-text">Web Search Results</span>
                </div>
                <div class="text-xs text-light-text-subtle dark:text-dark-text-subtle mb-3">
                    Query: "${result.query}" | Depth: ${result.search_depth} | Results: ${result.results.length}
                </div>
                ${result.answer ? `
                    <div class="mb-4 p-3 bg-accent/10 rounded">
                        <div class="text-xs font-medium text-accent mb-1">AI Answer</div>
                        <div class="text-sm text-light-text dark:text-dark-text">${result.answer}</div>
                    </div>
                ` : ''}
                <div class="space-y-3">
                    ${result.results.map(item => `
                        <div class="border border-light-border dark:border-dark-border rounded p-3">
                            <div class="font-medium text-sm text-light-text dark:text-dark-text mb-1">
                                <a href="${item.url}" target="_blank" class="text-accent hover:underline">${item.title}</a>
                            </div>
                            <div class="text-xs text-light-text-subtle dark:text-dark-text-subtle line-clamp-2">${item.content}</div>
                            <div class="text-xs text-accent mt-1">${item.url}</div>
                        </div>
                    `).join('')}
                </div>
            `;
            break;

        default:
            container.innerHTML = `
                <div class="flex items-center gap-2 mb-2">
                    <span class="text-lg">⚙️</span>
                    <span class="text-sm font-medium text-light-text dark:text-dark-text">Function Result</span>
                </div>
                <pre class="text-xs bg-black/10 dark:bg-white/10 p-2 rounded overflow-auto">${JSON.stringify(result, null, 2)}</pre>
            `;
    }

    return container;
}

// --- Image Generation Functions ---
async function handleImageGeneration(prompt, model) {
    const token = await validateAndRefreshToken();
    if (!token) {
        showAlert('Authentication required for image generation.', 'warning');
        return;
    }

    // Check if we need to upload an image first (for image-to-image models)
    let imageUrl = null;
    const imageDataToUpload = attachedImageData?.dataUrl || null;
    const modelsSupportingImageInput = new Set(['pollinations-kontext', 'nanobanana', 'seedream']);

    if (attachmentDownloadPromise && modelsSupportingImageInput.has(model)) {
        try {
            await attachmentDownloadPromise;
        } catch (error) {
            console.error('Failed to finish preparing image attachment for generation:', error);
            showAlert('Image attachment could not be prepared. Please reattach and try again.', 'error', 4000);
            clearAttachedImage();
            return;
        }
    }

    if (modelsSupportingImageInput.has(model) && imageDataToUpload) {
        try {
            const uploadResponse = await fetch(`${API_BASE_URL}/api/ai/images/upload`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ image: imageDataToUpload })
            });

            if (uploadResponse.ok) {
                const uploadData = await uploadResponse.json();
                imageUrl = uploadData.url;
                console.log('✅ Image uploaded successfully:', imageUrl);
            } else {
                throw new Error('Failed to upload image');
            }
        } catch (error) {
            console.error('❌ Error uploading image:', error);
            alert('Failed to upload image. Please try again.');
            return;
        }
    }

    // Clear the input field immediately after sending
    elements.userInput.value = '';
    elements.userInput.style.height = 'auto'; // Reset height

    const previewImageDataUrl = getAttachmentDataUrl();
    const previewImageUrl = getAttachmentPreviewUrl();
    const displayImageUrl = imageUrl || previewImageUrl || previewImageDataUrl;
    const userMessageContent = previewImageUrl
        ? [
            { type: 'text', text: prompt },
            { type: 'image_url', image_url: { url: displayImageUrl } }
        ]
        : prompt;

    addMessage('user', userMessageContent);
    const assistantMessageObj = { role: 'assistant', content: '...', id: 'assistant-msg-' + Date.now() };
    const activeChat = state.chats.find(c => c.id === state.activeId);
    activeChat.messages.push(assistantMessageObj);
    renderChat();
    scrollToBottom();

    const assistantMsgDiv = document.getElementById(assistantMessageObj.id);
    // New box-shaped loader
    assistantMsgDiv.innerHTML = `
        <div class="w-64 h-64 bg-light-border dark:bg-dark-border rounded-lg flex items-center justify-center">
            <div class="loading-spinner"></div>
        </div>
    `;

    try {
        const result = await generateImage(prompt, model, imageUrl);
        if (result && result.url) {
            const finalImageUrl = result.url;
            const revisedPrompt = result.revised_prompt || prompt;

            const renderImageMessage = (html, metadata = {}) => {
                activeChat.messages[activeChat.messages.length - 1].content = {
                    type: 'html',
                    html,
                    metadata: {
                        imageUrl: finalImageUrl,
                        prompt: revisedPrompt,
                        model,
                        ...metadata
                    }
                };
                renderChat();
                scrollToBottom();
                immediateSaveState(); // Critical state change - save immediately when image generation completes
            };

            const assistantMsgDiv = document.getElementById(assistantMessageObj.id);

            const attemptImageLoad = (attempt = 0) => {
                const tempImg = new Image();
                tempImg.crossOrigin = 'anonymous';
                tempImg.onload = async () => {
                    const imageContent = `
                        <p>Here is the generated image:</p>
                        <div class="mt-2 relative" style="max-width: 400px; max-height: 600px; overflow: hidden; border-radius: 0.5rem;">
                            <img src="${finalImageUrl}" alt="${revisedPrompt}" style="width: 100%; height: auto; display: block; border-radius: 0.5rem;"/>
                            <button type="button" class="edit-generated-image-btn absolute bottom-4 left-4 flex items-center justify-center w-10 h-10 rounded-full bg-light-sidebar dark:bg-dark-sidebar text-light-text dark:text-dark-text border border-light-border dark:border-dark-border shadow-md hover:bg-light-border-hover dark:hover:bg-dark-border-hover transition-colors" data-image-url="${finalImageUrl}" title="Edit this image">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 1 1 3 3L7 19l-4 1 1-4Z"></path></svg>
                            </button>
                        </div>
                    `;
                    renderImageMessage(imageContent);
                    clearAttachedImage();

                    const userMessageForSave = activeChat.messages[activeChat.messages.length - 2];
                    const assistantMessageForSave = activeChat.messages[activeChat.messages.length - 1];
                    if (userMessageForSave && assistantMessageForSave) {
                        await saveMessagesToServer(activeChat.id, userMessageForSave, assistantMessageForSave, token);
                    }
                };
                tempImg.onerror = () => {
                    const delay = Math.min(5000, 1000 + attempt * 500);
                    console.warn(`Image preview not ready yet (retry in ${delay}ms)`);
                    if (assistantMsgDiv) {
                        assistantMsgDiv.innerHTML = `
                            <div class="w-64 h-64 bg-light-border dark:bg-dark-border rounded-lg flex flex-col items-center justify-center text-center gap-3 p-4">
                                <div class="loading-spinner"></div>
                                <p class="text-sm text-light-text-subtle dark:text-dark-text-subtle">Preparing your image...</p>
                            </div>
                        `;
                    }
                    setTimeout(() => attemptImageLoad(attempt + 1), delay);
                };

                const cacheBustingUrl = finalImageUrl + (finalImageUrl.includes('?') ? '&' : '?') + 't=' + Date.now();
                tempImg.src = cacheBustingUrl;
            };

            attemptImageLoad();
        } else {
            throw new Error('Image generation failed to return a valid URL.');
        }
    } catch (error) {
        const errorContent = `<p class="text-red-500">Error generating image: ${error.message}</p>`;
        activeChat.messages[activeChat.messages.length - 1].content = {
            type: 'html',
            html: errorContent,
            metadata: {
                model,
                prompt
            }
        };

        renderChat();
        scrollToBottom();
        immediateSaveState(); // Critical state change - save immediately when image generation fails
        clearAttachedImage();

        const userMessageForSave = activeChat.messages[activeChat.messages.length - 2];
        const assistantMessageForSave = activeChat.messages[activeChat.messages.length - 1];
        if (userMessageForSave && assistantMessageForSave) {
            await saveMessagesToServer(activeChat.id, userMessageForSave, assistantMessageForSave, token);
        }
    }
}

async function generateImage(prompt, model = 'imagen-4', imageUrl = null) {
    const token = await validateAndRefreshToken();
    if (!token) {
        throw new Error('Authentication required for image generation.');
    }

    const response = await fetch(`${API_BASE_URL}/api/ai/images/generations`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
            model: model,
            prompt: prompt,
            n: 1,
            size: '1024x1024',
            response_format: 'url',
            ...(imageUrl && { image: imageUrl })
        })
    });

    if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Image generation failed.');
    }

    const data = await response.json();
    if (data.data && data.data[0] && data.data[0].url) {
        return data.data[0];
    } else {
        throw new Error('Invalid response from image generation API.');
    }
}

function getBase64FromImage(imgElement) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = imgElement.naturalWidth;
        canvas.height = imgElement.naturalHeight;

        ctx.drawImage(imgElement, 0, 0);

        canvas.toBlob((blob) => {
            const reader = new FileReader();
            reader.onload = () => {
                const base64String = reader.result;
                resolve(base64String);
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        }, 'image/png');
    });
}

    function copyMessage(content, btn) {
    let textToCopy = '';

    if (typeof content === 'string') {
        const trimmed = content.trim();
        if ((trimmed.startsWith('{') || trimmed.startsWith('['))) {
            try {
                const parsed = JSON.parse(trimmed);
                return copyMessage(parsed, btn);
            } catch (e) {
                textToCopy = content;
            }
        } else {
            textToCopy = content;
        }
    } else if (Array.isArray(content)) {
        textToCopy = content
            .map(part => {
                if (part.type === 'text') {
                    return part.text;
                }
                if (part.type === 'image_url' && part.image_url?.url) {
                    return part.image_url.url;
                }
                return '';
            })
            .filter(Boolean)
            .join('\n');
    } else if (content && typeof content === 'object') {
        if (content.type === 'html' && content.html) {
            const temp = document.createElement('div');
            temp.innerHTML = content.html;
            textToCopy = temp.textContent || temp.innerText || '';
        } else if (content.type === 'text' && content.text) {
            textToCopy = content.text;
        } else {
            textToCopy = JSON.stringify(content);
        }
    }

    navigator.clipboard.writeText(textToCopy).then(() => {
        const originalIcon = btn.innerHTML;
        btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
        setTimeout(() => btn.innerHTML = originalIcon, 1500);
    });
};
    function enterEditMode(chatId, messageIndex) {
    const chat = state.chats.find(c => c.id === chatId);
    if (!chat) return;

    const message = chat.messages[messageIndex];
    if (!message) return;
    
    // Clear any previous image preview first
    const imagePreviewContainer = document.getElementById('image-preview-container');
    imagePreviewContainer.innerHTML = '';
    imagePreviewContainer.classList.add('hidden');
    attachedImageData = null;
    const imageUploadEl = document.getElementById('image-upload');
    if (imageUploadEl) imageUploadEl.value = null;

    // Check if the message content is an array (multimodal) or a string
    if (Array.isArray(message.content)) {
        const textPart = message.content.find(p => p.type === 'text');
        const imagePart = message.content.find(p => p.type === 'image_url');

        // Set the text input
        elements.userInput.value = textPart ? textPart.text : '';

        // If an image part exists, display it and set the state
        if (imagePart && imagePart.image_url.url) {
            attachedImageData = { dataUrl: imagePart.image_url.url }; // Set the state for resending
            
            // Re-use the preview logic to display the image
            imagePreviewContainer.innerHTML = `
                <div class="relative inline-block">
                    <img src="${imagePart.image_url.url}" class="h-20 w-20 object-cover rounded-lg">
                    <button id="remove-image-btn" class="absolute top-0 right-0 -mt-2 -mr-2 bg-red-500 text-white rounded-full p-1 leading-none">
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>
                </div>
            `;
            imagePreviewContainer.classList.remove('hidden');

            document.getElementById('remove-image-btn').onclick = () => {
                clearAttachedImage();
            };
        }
    } else {
        // Handle legacy/text-only messages
        elements.userInput.value = message.content;
    }

    // --- The rest of the function remains the same ---
    state.editingMessage = { chatId, messageIndex };
    elements.userInput.focus();
    elements.sendIcon.classList.add('hidden');
    elements.saveIcon.classList.remove('hidden');
    elements.editIndicator.classList.remove('hidden');
}
    function exitEditMode() {
        state.editingMessage = null;
        elements.userInput.value = '';
        elements.sendIcon.classList.remove('hidden');
        elements.saveIcon.classList.add('hidden');
        elements.editIndicator.classList.add('hidden');
        elements.editIndicator.classList.remove('flex');

        // Clear image preview
        attachedImageData = null;
        document.getElementById('image-upload').value = null;
        const imagePreviewContainer = document.getElementById('image-preview-container');
        imagePreviewContainer.innerHTML = '';
        imagePreviewContainer.classList.add('hidden');

        renderChat();
    };
    function toggleSidebar() { const isMobile = window.innerWidth < 768; elements.sidebar.classList.toggle(isMobile ? 'open' : 'closed'); if (isMobile) elements.sidebarOverlay.classList.toggle('open'); };
    
    // --- Modal Control with Anime.js ---
    function animateModalOpen(modalContainer) {
        modalContainer.style.display = 'flex';
        const modalContent = modalContainer.querySelector('.modal-content');
        anime({ targets: modalContent, scale: [0.92, 1], opacity: [0, 1], duration: 250, easing: 'easeOutCubic' });
    }
    function animateModalClose(modalContainer, onComplete = () => {}) {
        const modalContent = modalContainer.querySelector('.modal-content');
        anime({ targets: modalContent, scale: 0.95, opacity: 0, duration: 100, easing: 'easeInCubic', complete: () => { modalContainer.style.display = 'none'; onComplete(); } });
    }
    function openRenameModal(chatId) { state.modalContext.chatId = chatId; const chat = state.chats.find(c=>c.id === chatId); if(!chat) return; elements.renameModal.input.value = chat.title; animateModalOpen(elements.renameModal.container); }
    function openDeleteModal(chatId) { state.modalContext.chatId = chatId; const chat = state.chats.find(c=>c.id === chatId); if(!chat) return; elements.deleteModal.message.textContent = `Are you sure you want to delete "${chat.title}"?`; animateModalOpen(elements.deleteModal.container); }
    function closeAllModals() { 
        document.querySelectorAll('.modal-container').forEach(m => { if (m.style.display === 'flex') animateModalClose(m); }); 
        elements.chatActionsDropdown.style.display = 'none';
    }

    function openChatActionsDropdown(chatId, target) {
        const rect = target.getBoundingClientRect();
        const dropdown = elements.chatActionsDropdown;
        dropdown.innerHTML = `
            <button class="rename-action w-full text-left px-3 py-2 text-sm hover:bg-light-border-hover dark:hover:bg-dark-border-hover flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>
                Rename
            </button>
            <button class="delete-action w-full text-left px-3 py-2 text-sm text-red-500 hover:bg-light-border-hover dark:hover:bg-dark-border-hover flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                Delete
            </button>
        `;
        dropdown.querySelector('.rename-action').onclick = () => {
    openRenameModal(chatId);
    dropdown.style.display = 'none'; // Correct: Only hide the dropdown
};

        dropdown.querySelector('.delete-action').onclick = () => {
    openDeleteModal(chatId);
    dropdown.style.display = 'none'; // Correct: Only hide the dropdown
};        
        dropdown.style.top = `${rect.bottom + 4}px`;
        dropdown.style.left = `${rect.left - dropdown.offsetWidth + rect.width}px`;
        dropdown.style.display = 'block';

        setTimeout(() => {
            document.addEventListener('click', function hide(e) {
                if (!dropdown.contains(e.target)) {
                    dropdown.style.display = 'none';
                    document.removeEventListener('click', hide);
                }
            });
        }, 0);
    }
    
    // --- Font Settings ---
    function applyFont(font) { Object.keys(FONTS).forEach(f => elements.body.classList.remove(`font-${f}`)); elements.body.classList.add(`font-${font}`); state.settings.font = font; debouncedSaveState(); renderFontOptions(); }
    function applyFontWeight(weight) { elements.body.style.fontWeight = weight; state.settings.fontWeight = weight; debouncedSaveState(); renderFontWeightOptions(); }
    function renderFontOptions() { const currentFont = state.settings.font; elements.settingsModal.fontOptions.innerHTML = '<div><label class="text-sm font-medium text-light-text-subtle dark:text-dark-text-subtle">Font Family</label></div>'; Object.entries(FONTS).forEach(([key, name]) => { const btn = document.createElement('button'); btn.className = `w-full text-left px-3 py-2 rounded-md transition-colors text-sm ${currentFont === key ? 'bg-accent text-white font-semibold' : 'hover:bg-light-border-hover dark:hover:bg-dark-border-hover'}`; btn.textContent = name; btn.onclick = () => { applyFont(key); }; elements.settingsModal.fontOptions.appendChild(btn); }); }
    function renderFontWeightOptions() { const currentWeight = state.settings.fontWeight; elements.settingsModal.fontWeightOptions.innerHTML = `<div class="flex justify-between items-center"><label class="text-sm font-medium text-light-text-subtle dark:text-dark-text-subtle">Font Weight</label><span id="font-weight-label" class="text-sm text-light-text-subtle dark:text-dark-text-subtle">${FONT_WEIGHTS[currentWeight]}</span></div><input type="range" id="font-weight-slider" class="w-full h-2 bg-light-border dark:bg-dark-border rounded-lg appearance-none cursor-pointer accent-accent" min="0" max="${Object.keys(FONT_WEIGHTS).length - 1}" step="1" value="${Object.keys(FONT_WEIGHTS).indexOf(currentWeight)}">`; document.getElementById('font-weight-slider').addEventListener('input', (e) => { const weight = Object.keys(FONT_WEIGHTS)[e.target.value]; applyFontWeight(weight); document.getElementById('font-weight-label').textContent = FONT_WEIGHTS[weight]; }); }
    
    // --- Model Selection ---
    function updateModelSelectorDisplay() {
      const currentModel = state.settings.model || 'openai';
      const modelData = MODELS[currentModel] || { name: 'Unknown Model', type: 'text' };
      const displayName = modelData.name;
      const modelType = modelData.type === 'image' ? ' 🎨' : ' 💬';
      elements.chatTitle.textContent = displayName + modelType;
      console.log('🔄 Updated model selector display to:', displayName, `(${modelData.type})`);
    }

    function updateProModelsToggleUI() {
        const enabled = state.settings.proModelsEnabled;
        const toggle = elements.settingsModal.proModelsToggle;
        const knob = toggle.querySelector('span');
        
        toggle.setAttribute('aria-checked', enabled.toString());
        toggle.classList.toggle('bg-accent', enabled);
        toggle.classList.toggle('bg-gray-200', !enabled);
        toggle.classList.toggle('dark:bg-gray-700', !enabled);
        knob.classList.toggle('translate-x-5', enabled);
        knob.classList.toggle('translate-x-0', !enabled);
    }
    
    function updateBetaModelsToggleUI() {
        const enabled = state.settings.betaModelsEnabled;
        const toggle = elements.settingsModal.betaModelsToggle;
        const knob = toggle.querySelector('span');
        
        toggle.setAttribute('aria-checked', enabled.toString());
        toggle.classList.toggle('bg-accent', enabled);
        toggle.classList.toggle('bg-gray-200', !enabled);
        toggle.classList.toggle('dark:bg-gray-700', !enabled);
        knob.classList.toggle('translate-x-5', enabled);
        knob.classList.toggle('translate-x-0', !enabled);
    }

    function renderModelDropdown() {
      elements.modelDropdown.innerHTML = '';
      
      const isProUser = state.currentUser && state.currentUser.plan === 'pro';
      const proModelsEnabled = state.settings.proModelsEnabled;
      const betaModelsEnabled = state.settings.betaModelsEnabled;
      const isAnonymous = isAnonymousUser();
      const isLoggedIn = !isAnonymous;

      // Separate models by type first, then filter
      const textModels = Object.entries(MODELS).filter(([_, data]) => data.type === 'text');
      const imageModels = Object.entries(MODELS).filter(([_, data]) => data.type === 'image');
      
      // Sort text models: available first, unavailable last
      const sortedTextModels = textModels.sort((a, b) => {
        const isAUnavailable = !isModelAvailable(a[0]);
        const isBUnavailable = !isModelAvailable(b[0]);
        
        // If availability is different, sort by availability (available first)
        if (isAUnavailable !== isBUnavailable) {
          return isAUnavailable ? 1 : -1;
        }
        
        // If both have same availability status, maintain original order
        return 0;
      });
      
      // Sort image models similarly
      const sortedImageModels = imageModels.sort((a, b) => {
        const isAUnavailable = !isModelAvailable(a[0]);
        const isBUnavailable = !isModelAvailable(b[0]);
        
        if (isAUnavailable !== isBUnavailable) {
          return isAUnavailable ? 1 : -1;
        }
        
        return 0;
      });
      
      // Add Text Models section
      const textHeader = document.createElement('div');
      textHeader.className = 'px-3 py-2 text-xs font-medium text-light-text-subtle dark:text-dark-text-subtle uppercase tracking-wider border-b border-light-border dark:border-dark-border';
      textHeader.textContent = '💬 Text Models';
      elements.modelDropdown.appendChild(textHeader);
      
      sortedTextModels.forEach(([key, data]) => {
        const btn = document.createElement('button');
        const isSelected = key === state.settings.model;
        
        // Determine model status
        const requiresLogin = doesModelRequireLogin(key);
        const requiresPro = data.pro && (!isProUser || !proModelsEnabled);
        const requiresBeta = data.beta && (!isLoggedIn || !betaModelsEnabled);
        const isUnavailable = !isModelAvailable(key);
        const isDisabled = requiresLogin || requiresPro || requiresBeta || isUnavailable;
        
        // Set button classes based on status
        let btnClasses = 'w-full text-left px-3 py-2 text-sm transition-colors flex items-center justify-between';
        if (isDisabled) {
            btnClasses += ' opacity-60 cursor-not-allowed';
        } else if (isSelected) {
            btnClasses += ' bg-accent text-white';
        } else {
            btnClasses += ' hover:bg-light-border-hover dark:hover:bg-dark-border-hover';
        }
        btn.className = btnClasses;
        
        // Build badge/status indicators
        let badges = '';
        if (data.pro) {
            badges += '<span class="flex items-center justify-center w-5 h-5 text-accent ml-2" title="PRO Model"><i data-lucide="crown" class="w-4 h-4"></i></span>';
        }
        if (data.beta) {
            badges += '<span class="flex items-center justify-center w-5 h-5 text-purple-600 ml-2" title="BETA Model"><i data-lucide="flask-conical" class="w-4 h-4"></i></span>';
        }
        if (isAnonymous && data.anonymous) {
            badges += '<span class="flex items-center justify-center w-5 h-5 text-green-600 ml-2" title="Free Model"><i data-lucide="zap" class="w-4 h-4"></i></span>';
        }
        if (isUnavailable) {
            badges += '<span class="flex items-center justify-center w-5 h-5 text-red-600 ml-2" title="Model Unavailable"><i data-lucide="alert-triangle" class="w-4 h-4"></i></span>';
        }

        btn.innerHTML = `<span>${data.name}</span><div class="flex items-center">${badges}</div>`;
        
        // Handle click event
        btn.onclick = () => {
            if (isDisabled) {
                // Show appropriate alert for disabled models
                if (requiresLogin) {
                    showAlert('This model requires you to sign in. Please log in to use this model.', 'warning');
                } else if (requiresPro) {
                    showAlert('This is a pro model. You need a pro plan and to enable pro models in settings.', 'warning');
                } else if (requiresBeta) {
                    showAlert('This is a beta model. You need to be logged in and enable beta models in settings.', 'warning');
                } else if (isUnavailable) {
                    showAlert('This model is currently unavailable. Please try again later.', 'error');
                }
                return;
            }
            
            // Model is available, select it
            state.settings.model = key;
            const activeChat = state.chats.find(c => c.id === state.activeId);
            if (activeChat) activeChat.model = key;
            saveState();
            updateModelSelectorDisplay();
            renderModelDropdown();
            elements.modelDropdown.style.display = 'none';
            const dropdownArrow = document.getElementById('model-dropdown-arrow');
            if (dropdownArrow) {
              dropdownArrow.style.transform = 'rotate(0deg)';
            }
        };
        
        elements.modelDropdown.appendChild(btn);
      });
      
      // Add Image Generation section
      if (imageModels.length > 0) {
        const imgHeader = document.createElement('div');
        imgHeader.className = 'px-3 py-2 text-xs font-medium text-light-text-subtle dark:text-dark-text-subtle uppercase tracking-wider border-b border-light-border dark:border-dark-border mt-2';
        imgHeader.textContent = '🎨 Image Generation';
        elements.modelDropdown.appendChild(imgHeader);
        
        sortedImageModels.forEach(([key, data]) => {
          const btn = document.createElement('button');
          const isSelected = key === state.settings.model;
          
          // Determine model status
          const requiresLogin = doesModelRequireLogin(key);
          const requiresPro = data.pro && (!isProUser || !proModelsEnabled);
          const requiresBeta = data.beta && (!isLoggedIn || !betaModelsEnabled);
          const isUnavailable = !isModelAvailable(key);
          const isDisabled = requiresLogin || requiresPro || requiresBeta || isUnavailable;
          
          // Set button classes based on status
          let btnClasses = 'w-full text-left px-3 py-2 text-sm transition-colors flex items-center justify-between';
          if (isDisabled) {
              btnClasses += ' opacity-60 cursor-not-allowed';
          } else if (isSelected) {
              btnClasses += ' bg-accent text-white';
          } else {
              btnClasses += ' hover:bg-light-border-hover dark:hover:bg-dark-border-hover';
          }
          btn.className = btnClasses;
          
          // Build badge/status indicators
          let badges = '';
          if (data.pro) {
              badges += '<span class="flex items-center justify-center w-5 h-5 text-accent ml-2" title="PRO Model"><i data-lucide="crown" class="w-4 h-4"></i></span>';
          }
          if (isUnavailable) {
              badges += '<span class="flex items-center justify-center w-5 h-5 text-red-600 ml-2" title="Model Unavailable"><i data-lucide="alert-triangle" class="w-4 h-4"></i></span>';
          }

          btn.innerHTML = `<span>${data.name}</span><div class="flex items-center">${badges}</div>`;
          
          // Handle click event
          btn.onclick = () => {
              if (isDisabled) {
                  // Show appropriate alert for disabled models
                  if (requiresLogin) {
                      showAlert('This model requires you to sign in. Please log in to use this model.', 'warning');
                  } else if (requiresPro) {
                      showAlert('This is a pro model. You need a pro plan and to enable pro models in settings.', 'warning');
                  } else if (isUnavailable) {
                      showAlert('This model is currently unavailable. Please try again later.', 'error');
                  }
                  return;
              }
              
              // Model is available, select it
              state.settings.model = key;
              const activeChat = state.chats.find(c => c.id === state.activeId);
              if (activeChat) activeChat.model = key;
              saveState();
              updateModelSelectorDisplay();
              renderModelDropdown();
              elements.modelDropdown.style.display = 'none';
              const dropdownArrow = document.getElementById('model-dropdown-arrow');
              if (dropdownArrow) {
                dropdownArrow.style.transform = 'rotate(0deg)';
              }
              console.log('🖼️ Selected image model:', key);
          };
          
          elements.modelDropdown.appendChild(btn);
        });
      }
    }

    // Enhanced theme application with validation and smooth transitions
    function applyTheme(theme) {
        // Validate theme input
        const validThemes = ['light', 'dark'];
        const sanitizedTheme = validThemes.includes(theme) ? theme : 'light';

        // Add transition class for smooth animations
        document.documentElement.classList.add('theme-transitioning');

        const isDark = sanitizedTheme === 'dark';
        document.documentElement.classList.toggle('dark', isDark);

        // Update theme icons with smooth transitions
        const lightIcon = document.getElementById('theme-icon-light');
        const darkIcon = document.getElementById('theme-icon-dark');

        if (lightIcon && darkIcon) {
            // Use opacity transitions for smooth icon changes
            lightIcon.style.transition = 'opacity 0.2s ease';
            darkIcon.style.transition = 'opacity 0.2s ease';

            lightIcon.style.opacity = isDark ? '0' : '1';
            darkIcon.style.opacity = isDark ? '1' : '0';

            // Update visibility after transition
            setTimeout(() => {
                lightIcon.classList.toggle('hidden', isDark);
                darkIcon.classList.toggle('hidden', !isDark);
                lightIcon.style.opacity = '';
                darkIcon.style.opacity = '';
            }, 200);
        }

        // Save theme preference with error handling
        try {
            localStorage.setItem('theme', sanitizedTheme);
        } catch (error) {
            console.warn('[Theme] Failed to save theme preference:', error);
        }

        // Remove transition class after animation completes
        setTimeout(() => {
            document.documentElement.classList.remove('theme-transitioning');
        }, 300);

        console.log(`[Theme] Applied theme: ${sanitizedTheme}`);
    }

    // Enhanced theme toggle with comprehensive browser compatibility
    function toggleTheme(event) {
        const currentTheme = localStorage.getItem('theme') || 'light';
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

        // Check for reduced motion preference
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        // Try View Transitions API first (modern browsers)
        if (document.startViewTransition && !prefersReducedMotion) {
            try {
                // Calculate transition origin if click event provided
                let cx = '50%';
                let cy = '50%';

                if (event && event.target) {
                    const btn = event.target.closest('button');
                    if (btn) {
                        const rect = btn.getBoundingClientRect();
                        cx = `${rect.left + rect.width / 2}px`;
                        cy = `${rect.top + rect.height / 2}px`;
                    }
                }

                // Set transition coordinates
                document.documentElement.style.setProperty('--cx', cx);
                document.documentElement.style.setProperty('--cy', cy);

                const transition = document.startViewTransition(() => {
                    applyTheme(newTheme);
                });

                // Handle transition failure gracefully
                transition.ready.catch((error) => {
                    console.warn('[Theme] View transition failed, falling back to standard transition:', error);
                    applyTheme(newTheme);
                });

                return;
            } catch (error) {
                console.warn('[Theme] View transition error, falling back to standard transition:', error);
            }
        }

        // Fallback for browsers without View Transitions support or reduced motion preference
        applyTheme(newTheme);
    }

    // Initialize theme system with proper CSS setup
    function initializeThemeSystem() {
        // Add CSS for smooth theme transitions
        const themeStyles = document.createElement('style');
        themeStyles.textContent = `
            .theme-transitioning * {
                transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease !important;
            }

            @media (prefers-reduced-motion: reduce) {
                .theme-transitioning * {
                    transition: none !important;
                }
            }

            /* View Transitions support */
            @view-transition {
                navigation: auto;
            }

            ::view-transition-old(root),
            ::view-transition-new(root) {
                animation-duration: 0.2s;
            }

            /* Enhanced focus styles for accessibility */
            .theme-toggle:focus {
                outline: 2px solid var(--accent-color);
                outline-offset: 2px;
            }
        `;
        document.head.appendChild(themeStyles);

        console.log('[Theme] Theme system initialized with enhanced transitions');
    }

    // --- REPLACE your entire old init() function with this ---
function init() {
    // 1. Initialize theme system with enhanced transitions
    initializeThemeSystem();

    // 2. Apply the user's preferred theme on startup.
    const savedTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
    applyTheme(savedTheme);
    
    // 2. Set up the master Supabase Authentication listener.
    // This function is the single source of truth for the user's login state.
    supabaseClient.auth.onAuthStateChange((event, session) => {
        if (event === 'SIGNED_IN' && session) {
            // This block runs after any successful login, including the redirect from Google.
            console.log('User signed in. Session:', session);
            localStorage.setItem('authToken', session.access_token);
            localStorage.setItem('refreshToken', session.refresh_token);
            
            // Update UI immediately for instant feedback
            if (session.user) {
                state.currentUser = { 
                    email: session.user.email,
                    id: session.user.id
                };
                updateLoginStateUI();
            }
            
            closeAllModals();
            
            // Load full data in background
            loadDataFromServer();
        } else if (event === 'SIGNED_OUT') {
            // This block runs after supabase.auth.signOut() is called successfully.
            // It resets the entire application to the logged-out state.
            localStorage.removeItem('authToken');
            localStorage.removeItem('refreshToken');
            clearCachedChats(); // Clear cached chats
            state.currentUser = null;
            state.chats = [];
            state.activeId = null;
            updateLoginStateUI();
            renderSidebar();
            renderChat();
            console.log('User signed out.');
        }
    });

    // 3. Load user settings (like fonts, API token) from previous sessions.
    // Note: We no longer load chats from here; they come from the server.
    const d = localStorage.getItem('fronixState');
    if (d) {
        const p = JSON.parse(d);
        state.settings = { ...state.settings, ...p.settings };
        if (p.settings.apiToken) elements.settingsModal.apiTokenInput.value = p.settings.apiToken;
    }
    
    // 4. Check if a token already exists when the page first loads (for returning users).
    // This is important because onAuthStateChange might not fire immediately for an existing session.
    const existingToken = localStorage.getItem('authToken');
    if (existingToken) {
        console.log('An existing auth token was found on page load.');
        
        // First, try to load cached chats for instant UI
        const cachedLoaded = loadCachedChats();
        
        if (cachedLoaded) {
            // We have cached data - show it immediately and refresh in background
            console.log('[init] Showing cached data instantly, refreshing in background');
            updateLoginStateUI();
            updateProfileUI();
            
            // Background refresh without disrupting UI
            setTimeout(() => {
                loadDataFromServer(0, true); // Silent load
            }, 100);
        } else {
            // No cached data available - load normally
            console.log('[init] No cached data available, loading from server');
            loadDataFromServer();
        }
    } else {
        // If no token exists, ensure the UI is in the logged-out state.
        updateLoginStateUI();
    }
    
    // 5. Apply UI settings and attach all event listeners.
    applyFont(state.settings.font);
    applyFontWeight(state.settings.fontWeight);
    renderFontOptions();
    renderFontWeightOptions();
    updateProModelsToggleUI();
    
    elements.settingsModal.apiTokenInput.addEventListener('change', (e) => {
        state.settings.apiToken = e.target.value;
        saveState();
    });

    elements.settingsModal.proModelsToggle.addEventListener('click', () => {
        if (state.currentUser && state.currentUser.plan === 'pro') {
            state.settings.proModelsEnabled = !state.settings.proModelsEnabled;
            updateProModelsToggleUI();
            saveState();
            renderModelDropdown();
        } else {
            showAlert('You need a pro plan to use pro models. Contact @zshadowultra on Discord for access.', 'warning');
        }
    });

    // Initial state update for send button
    updateSendButtonState();

    // Dynamic click handler for send/stop button
    elements.sendBtn.onclick = () => {
        if (isStreaming) {
            // Button is in stop state - abort the stream
            if (currentController) currentController.abort();
        } else {
            // Button is in send state - send message
            sendMessage();
        }
    };

    elements.scrollToBottomBtn.onclick = scrollToBottom;

    elements.chatBox.parentElement.addEventListener('scroll', () => {
        const { scrollTop, scrollHeight, clientHeight } = elements.chatBox.parentElement;
        const atBottom = scrollHeight - scrollTop - clientHeight < 50;
        isScrolledUp = !atBottom;

        if (isScrolledUp && isStreaming) {
            elements.scrollToBottomBtn.classList.add('opacity-100');
            elements.scrollToBottomBtn.classList.remove('opacity-0', 'pointer-events-none');
        } else {
            elements.scrollToBottomBtn.classList.remove('opacity-100');
            elements.scrollToBottomBtn.classList.add('opacity-0', 'pointer-events-none');
        }
    });

    // Initialize mobile sidebar state (collapsed by default on mobile)
    if (isMobile()) {
        elements.sidebar.classList.remove('open');
        elements.sidebarOverlay.classList.remove('open');
        console.log('[init] Mobile detected - sidebar collapsed by default');
    }
    
    // Initialize default chat for new users (non-authenticated)
    if (!existingToken) {
        // Set appropriate default model for anonymous users
        if (!state.settings.model || !isModelAvailableForAnonymous(state.settings.model)) {
            state.settings.model = 'gpt-4.1'; // Default anonymous model
            console.log('[init] Set default anonymous model to gpt-4.1');
        }
        
        // Load anonymous chats from localStorage
        const anonymousChats = loadAnonymousChats();
        if (anonymousChats.length > 0) {
            state.chats = anonymousChats;
            state.activeId = anonymousChats[0].id;
            console.log('[init] Loaded', anonymousChats.length, 'anonymous chats from localStorage');
            renderSidebar();
            renderChat();
        } else {
            initializeDefaultChat();
            console.log('[init] No existing token - initialized default chat');
        }
    }
    
    // Fetch model availability on startup
    fetchModelAvailability();

    // Fetch optimization statistics and show benefits
    fetchOptimizationStats();

    // Set up periodic model availability checks (every 10 minutes)
    setInterval(() => {
        fetchModelAvailability();
    }, 10 * 60 * 1000);
    
    // Update model selector display for anonymous users
    if (!existingToken) {
        updateModelSelectorDisplay();
    }
    
    setActive(state.activeId);

    // Image attachment logic
    const attachBtn = document.getElementById('attach-btn');
    const imageUpload = document.getElementById('image-upload');
    const imagePreviewContainer = document.getElementById('image-preview-container');

    attachBtn.onclick = () => imageUpload.click();

    imageUpload.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        
        // Check file size (50MB limit)
        const maxSize = 50 * 1024 * 1024; // 50MB in bytes
        if (file.size > maxSize) {
            showAlert('File size must be less than 50MB.', 'warning');
            imageUpload.value = null;
            return;
        }
        
        const reader = new FileReader();
        reader.onload = (e) => {
            attachedImageData = { file: file, dataUrl: e.target.result };

            imagePreviewContainer.innerHTML = `
                <div class="relative inline-block">
                    <img src="${e.target.result}" class="h-20 w-20 object-cover rounded-lg">
                    <button id="remove-image-btn" class="absolute top-0 right-0 -mt-2 -mr-2 bg-red-500 text-white rounded-full p-1 leading-none">
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>
                </div>
            `;
            imagePreviewContainer.classList.remove('hidden');

            document.getElementById('remove-image-btn').onclick = () => {
                clearAttachedImage();
            };
        };
        reader.readAsDataURL(file);
    });

    // --- Event Listeners ---
    elements.themeToggleBtn.onclick = toggleTheme;
    elements.newChatBtn.onclick = handleNewChat;
    elements.toggleSidebarBtn.onclick = toggleSidebar;
    elements.sidebarOverlay.onclick = toggleSidebar;
    elements.userInput.addEventListener('input', () => {
        elements.userInput.style.height = 'auto';
        elements.userInput.style.height = (elements.userInput.scrollHeight) + 'px';
        updateSendButtonState(); // Update button state on input change

        const inputValue = elements.userInput.value;
        if (inputValue.startsWith('/')) {
            elements.autocompleteSuggestions.classList.remove('hidden');
        } else {
            elements.autocompleteSuggestions.classList.add('hidden');
        }
    });

    elements.userInput.addEventListener('keydown', e => {
        const isMobile = window.innerWidth < 768;
        if (e.key === 'Enter' && !e.shiftKey) {
            if (!isMobile) {
                e.preventDefault();
                sendMessage();
            }
        }
    });

    elements.studyCommandBtn.addEventListener('click', () => {
        elements.userInput.value = '/study';
        elements.autocompleteSuggestions.classList.add('hidden');
        elements.userInput.focus();
    });
    elements.settingsBtn.onclick = () => animateModalOpen(elements.settingsModal.container);
    elements.settingsModal.closeBtn.onclick = () => animateModalClose(elements.settingsModal.container);
    elements.settingsModal.resetBtn.onclick = () => {
      localStorage.clear();
      window.location.reload();
    };
    elements.settingsModal.checkModelStatusBtn.onclick = () => showModelAvailability();
    elements.modelAvailabilityModal.closeBtn.onclick = () => closeModelAvailabilityModal();
    elements.renameModal.saveBtn.onclick = async () => {
        const { chatId } = state.modalContext;
        const newName = elements.renameModal.input.value.trim();
        if (!newName) return;

        const token = localStorage.getItem('authToken');
        if (!token) {
            showAlert("Authentication error. Please sign in again.", 'error');
            return;
        }

        const chatToRename = state.chats.find(c => c.id === chatId);
        if (!chatToRename) {
            closeAllModals();
            return;
        }
        const originalTitle = chatToRename.title; // Store original title for rollback

        // Optimistic UI update
        chatToRename.title = newName;
        if (chatId === state.activeId) {
            elements.chatTitle.textContent = newName;
        }
        console.log('[renameModal.saveBtn.onclick] State after optimistic update. state.chats:', JSON.parse(JSON.stringify(state.chats))); // Deep copy for logging
        console.log('[renameModal.saveBtn.onclick] State after optimistic update. state.activeId:', state.activeId);
        renderSidebar(); // Update sidebar immediately
        saveState();

        closeAllModals(); // Close modal immediately after optimistic update
        try {
            const response = await fetch(`${API_BASE_URL}/api/chat/${chatId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ title: newName })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to update chat title on server.');
            }

            // Backend confirmed, no further UI changes needed for success beyond optimistic update
            console.log(`Chat ${chatId} renamed successfully to "${newName}"`);

        } catch (error) {
            console.error("Error renaming chat:", error);
            showAlert(`Failed to rename chat: ${error.message}`, 'error');
            
            // Revert optimistic UI update on error
            chatToRename.title = originalTitle;
            if (chatId === state.activeId) {
                elements.chatTitle.textContent = originalTitle;
            }
            console.log('[renameModal.saveBtn.onclick] Error rollback. state.chats:', JSON.parse(JSON.stringify(state.chats))); // Deep copy for logging
            console.log('[renameModal.saveBtn.onclick] Error rollback. state.activeId:', state.activeId);
            renderSidebar(); // Re-render sidebar to show original title
            saveState();
        } finally { // Ensure button state is updated
            updateSendButtonState();
            console.log('[renameModal.saveBtn.onclick] Finally block executed. Button state updated.');
        }
    };
    elements.deleteModal.confirmBtn.onclick = async () => {
        const { chatId } = state.modalContext;
        const token = localStorage.getItem('authToken');
        if (!token) {
            alert("Authentication error. Please sign in again.");
            return;
        }

        const chatToDeleteIndex = state.chats.findIndex(c => c.id === chatId);
        if (chatToDeleteIndex === -1) {
            closeAllModals();
            return;
        }
        const chatToDelete = state.chats[chatToDeleteIndex]; // Store chat for rollback

        // Optimistic UI update: Remove chat from state and re-render
        state.chats.splice(chatToDeleteIndex, 1);
        
        let oldActiveId = state.activeId; // Store current activeId for potential rollback

        if (state.chats.length === 0) {
            state.activeId = null; // No chats left, clear activeId
        } else if (chatId === oldActiveId) {
            // If the deleted chat was the active one, activate the nearest chat
            state.activeId = state.chats[Math.max(0, chatToDeleteIndex - 1)]?.id || state.chats[0]?.id;
        }
        
        renderSidebar(); // Update sidebar immediately
        renderChat(); // Update chat area immediately
        saveState();
        closeAllModals(); // Close modal immediately after optimistic update

        try {
            const response = await fetch(`${API_BASE_URL}/api/chat/${chatId}`, {
                method: 'DELETE',
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to delete chat on server.');
            }

            // Backend confirmed, no further UI changes needed for success beyond optimistic update
            console.log(`Chat ${chatId} deleted successfully.`);
            // If no chats left after deletion, ensure a new chat is created
            if (state.chats.length === 0) {
                await handleNewChat();
            }

        } catch (error) {
            console.error("Error deleting chat:", error);
            showAlert(`Failed to delete chat: ${error.message}`, 'error');
            
            // Revert optimistic UI update on error
            state.chats.splice(chatToDeleteIndex, 0, chatToDelete); // Re-add chat
            state.activeId = oldActiveId; // Restore activeId
            console.log('[deleteModal.confirmBtn.onclick] Error rollback. state.chats:', JSON.parse(JSON.stringify(state.chats))); // Deep copy for logging
            console.log('[deleteModal.confirmBtn.onclick] Error rollback. state.activeId:', state.activeId);
            renderSidebar(); // Re-render sidebar
            renderChat(); // Re-render chat area
            saveState();
        } finally { // Ensure button state is updated
            updateSendButtonState();
            console.log('[deleteModal.confirmBtn.onclick] Finally block executed. Button state updated.');
        }
    };
    [elements.settingsModal.container, elements.renameModal.container, elements.deleteModal.container, elements.signinModal.container].forEach(el => el.onclick = (e) => { if (e.target === el) closeAllModals(); });
    [elements.renameModal.cancelBtn, elements.deleteModal.cancelBtn, elements.signinModal.closeBtn].forEach(el => el.onclick = closeAllModals);
    elements.cancelEditBtn.onclick = exitEditMode;
    updateSendButtonState(); // Call after exitEditMode
    console.log('[init] Initial button state update after exitEditMode listener setup.');
    elements.signinBtn.onclick = () => animateModalOpen(elements.signinModal.container);
    elements.logoutBtn.onclick = handleLogout;
    elements.profileBtn.onclick = () => {
        const isHidden = elements.profileDropdown.classList.contains('hidden');
        elements.profileDropdown.classList.toggle('hidden', !isHidden);
    };

    // Close profile dropdown if clicked outside
    document.addEventListener('click', (e) => {
        if (!elements.profileSection.contains(e.target)) {
            elements.profileDropdown.classList.add('hidden');
        }
    });
    
    // Sign In / Sign Up Toggle
    const signinTabBtn = document.getElementById('signin-tab-btn');
    const signupTabBtn = document.getElementById('signup-tab-btn');
    const signinView = document.getElementById('signin-view');
    const signupView = document.getElementById('signup-view');

    signinTabBtn.addEventListener('click', () => {
        signinView.classList.remove('hidden');
        signupView.classList.add('hidden');
        signinTabBtn.classList.add('text-accent', 'border-accent');
        signinTabBtn.classList.remove('text-light-text-subtle', 'dark:text-dark-text-subtle', 'border-transparent');
        signupTabBtn.classList.remove('text-accent', 'border-accent');
        signupTabBtn.classList.add('text-light-text-subtle', 'dark:text-dark-text-subtle', 'border-transparent');
    });

    signupTabBtn.addEventListener('click', () => {
        signupView.classList.remove('hidden');
        signinView.classList.add('hidden');
        signupTabBtn.classList.add('text-accent', 'border-accent');
        signupTabBtn.classList.remove('text-light-text-subtle', 'dark:text-dark-text-subtle', 'border-transparent');
        signinTabBtn.classList.remove('text-accent', 'border-accent');
        signinTabBtn.classList.add('text-light-text-subtle', 'dark:text-dark-text-subtle', 'border-transparent');
    });

    // Password visibility toggle
    const passwordInput = document.getElementById('password-input');
    const passwordToggleBtn = document.getElementById('password-toggle-btn');
    const eyeOpenIcon = document.getElementById('eye-open-icon');
    const eyeClosedIcon = document.getElementById('eye-closed-icon');

    passwordToggleBtn.addEventListener('click', () => {
        const isPassword = passwordInput.type === 'password';
        passwordInput.type = isPassword ? 'text' : 'password';
        eyeOpenIcon.classList.toggle('hidden', isPassword);
        eyeClosedIcon.classList.toggle('hidden', !isPassword);
    });

    // --- New Authentication Event Listeners ---
    document.getElementById('signin-email-btn').onclick = () => {
        const email = document.getElementById('signin-email').value;
        const password = document.getElementById('password-input').value;
        handleSignIn(email, password);
    };

    document.getElementById('signup-email-btn').onclick = () => {
        const email = document.getElementById('signup-email').value;
        const password = document.getElementById('signup-password').value;
        handleSignUp(email, password);
    };

    document.getElementById('signin-google-btn').onclick = handleGoogleLogin;
    document.getElementById('signup-google-btn').onclick = handleGoogleLogin;


    elements.modelSelector.onclick = () => {
      const isHidden = elements.modelDropdown.style.display === 'none' || elements.modelDropdown.style.display === '';
      const dropdownArrow = document.getElementById('model-dropdown-arrow');
      
      if (isHidden) {
        elements.modelDropdown.style.display = 'block';
        dropdownArrow.style.transform = 'rotate(180deg)';
        renderModelDropdown(); // Refresh the model list when opening
      } else {
        elements.modelDropdown.style.display = 'none';
        dropdownArrow.style.transform = 'rotate(0deg)';
      }
    };
    
    document.addEventListener('click', (e) => {
      if (!elements.modelSelector.contains(e.target) && !elements.modelDropdown.contains(e.target)) {
        elements.modelDropdown.style.display = 'none';
        const dropdownArrow = document.getElementById('model-dropdown-arrow');
        if (dropdownArrow) {
          dropdownArrow.style.transform = 'rotate(0deg)';
        }
      }
    });

    // Initialize Lucide icons after rendering the dropdown
    const initLucide = () => {
      if (window.lucide && window.lucide.createIcons) {
        window.lucide.createIcons();
      } else {
        console.warn('Lucide not loaded yet, retrying...');
        setTimeout(initLucide, 100); // Retry if not loaded
      }
    };

    // Ensure icons are updated whenever dropdown is rendered
    const _renderModelDropdown = renderModelDropdown;
    renderModelDropdown = function() {
      _renderModelDropdown.apply(this, arguments);
      setTimeout(initLucide, 10); // Small delay to ensure DOM is updated
    };

    // Initialize Lucide icons on startup
    setTimeout(initLucide, 100);
}






// Function to get available models
function getAvailableModels() {
    const models = [
        { id: 'gpt-4.1', name: 'GPT-4.1', provider: 'pollinations' },
        { id: 'gpt-5-nano', name: 'GPT-5 Nano', provider: 'pollinations' },
        { id: 'gemini', name: 'Gemini', provider: 'pollinations' },
        { id: 'deepseek-reasoning', name: 'DeepSeek Reasoning', provider: 'pollinations' },
        { id: 'openai-reasoning', name: 'OpenAI Reasoning', provider: 'pollinations' },
        { id: 'o4-mini-medium', name: 'O4 Mini Medium', provider: 'pollinations' },
        { id: 'o4-mini-high', name: 'O4 Mini High', provider: 'pollinations' }
    ];

    // Filter models based on user authentication and plan
    if (!state.currentUser) {
        return models.filter(m => m.provider === 'pollinations');
    }

    if (state.currentUser.plan === 'pro') {
        return [
            ...models,
            { id: 'gpt-5', name: 'GPT-5', provider: 'airforce' },
            { id: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro', provider: 'airforce' },
            { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash', provider: 'airforce' },
            { id: 'grok-4', name: 'Grok-4', provider: 'navy' }
        ];
    }

    return models;
}

// --- Event Listeners ---
document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>